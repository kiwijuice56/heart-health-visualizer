//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// preprocess_ppg_signal.cpp
//
// Code generation for function 'preprocess_ppg_signal'
//

// Include files
#include "preprocess_ppg_signal.h"
#include "preprocess_ppg_signal_types.h"
#include "rt_nonfinite.h"
#include "coder_array.h"
#include <algorithm>
#include <cmath>
#include <cstring>

// Type Definitions
namespace coder {
namespace internal {
namespace fft {
class FFTImplementationCallback {
public:
  static void doHalfLengthBluestein(const double x[100], creal_T y[100],
                                    const creal_T wwc[99],
                                    const double costabinv[129],
                                    const double sintabinv[129]);
};

} // namespace fft
} // namespace internal
} // namespace coder

// Variable Definitions
static const double dv[129]{1.0,
                            0.99969881869620425,
                            0.99879545620517241,
                            0.99729045667869021,
                            0.99518472667219693,
                            0.99247953459871,
                            0.989176509964781,
                            0.98527764238894122,
                            0.98078528040323043,
                            0.97570213003852857,
                            0.970031253194544,
                            0.96377606579543984,
                            0.95694033573220882,
                            0.94952818059303667,
                            0.94154406518302081,
                            0.932992798834739,
                            0.92387953251128674,
                            0.91420975570353069,
                            0.90398929312344334,
                            0.89322430119551532,
                            0.881921264348355,
                            0.87008699110871146,
                            0.85772861000027212,
                            0.84485356524970712,
                            0.83146961230254524,
                            0.81758481315158371,
                            0.80320753148064494,
                            0.78834642762660634,
                            0.773010453362737,
                            0.75720884650648457,
                            0.74095112535495922,
                            0.724247082951467,
                            0.70710678118654757,
                            0.68954054473706683,
                            0.67155895484701833,
                            0.65317284295377676,
                            0.63439328416364549,
                            0.61523159058062682,
                            0.59569930449243336,
                            0.57580819141784534,
                            0.55557023301960218,
                            0.53499761988709715,
                            0.51410274419322166,
                            0.49289819222978404,
                            0.47139673682599764,
                            0.44961132965460654,
                            0.42755509343028208,
                            0.40524131400498986,
                            0.38268343236508978,
                            0.35989503653498811,
                            0.33688985339222005,
                            0.31368174039889152,
                            0.29028467725446233,
                            0.26671275747489837,
                            0.24298017990326387,
                            0.2191012401568698,
                            0.19509032201612825,
                            0.17096188876030122,
                            0.14673047445536175,
                            0.1224106751992162,
                            0.0980171403295606,
                            0.073564563599667426,
                            0.049067674327418015,
                            0.024541228522912288,
                            0.0,
                            -0.024541228522912288,
                            -0.049067674327418015,
                            -0.073564563599667426,
                            -0.0980171403295606,
                            -0.1224106751992162,
                            -0.14673047445536175,
                            -0.17096188876030122,
                            -0.19509032201612825,
                            -0.2191012401568698,
                            -0.24298017990326387,
                            -0.26671275747489837,
                            -0.29028467725446233,
                            -0.31368174039889152,
                            -0.33688985339222005,
                            -0.35989503653498811,
                            -0.38268343236508978,
                            -0.40524131400498986,
                            -0.42755509343028208,
                            -0.44961132965460654,
                            -0.47139673682599764,
                            -0.49289819222978404,
                            -0.51410274419322166,
                            -0.53499761988709715,
                            -0.55557023301960218,
                            -0.57580819141784534,
                            -0.59569930449243336,
                            -0.61523159058062682,
                            -0.63439328416364549,
                            -0.65317284295377676,
                            -0.67155895484701833,
                            -0.68954054473706683,
                            -0.70710678118654757,
                            -0.724247082951467,
                            -0.74095112535495922,
                            -0.75720884650648457,
                            -0.773010453362737,
                            -0.78834642762660634,
                            -0.80320753148064494,
                            -0.81758481315158371,
                            -0.83146961230254524,
                            -0.84485356524970712,
                            -0.85772861000027212,
                            -0.87008699110871146,
                            -0.881921264348355,
                            -0.89322430119551532,
                            -0.90398929312344334,
                            -0.91420975570353069,
                            -0.92387953251128674,
                            -0.932992798834739,
                            -0.94154406518302081,
                            -0.94952818059303667,
                            -0.95694033573220882,
                            -0.96377606579543984,
                            -0.970031253194544,
                            -0.97570213003852857,
                            -0.98078528040323043,
                            -0.98527764238894122,
                            -0.989176509964781,
                            -0.99247953459871,
                            -0.99518472667219693,
                            -0.99729045667869021,
                            -0.99879545620517241,
                            -0.99969881869620425,
                            -1.0};

// Function Declarations
static int MultiWord2sLong(const unsigned int u[]);

static void MultiWordAdd(const unsigned int u1[], const unsigned int u2[],
                         unsigned int y[]);

static void MultiWordNeg(const unsigned int u1[], unsigned int y[]);

static void MultiWordSetUnsignedMax(unsigned int y[]);

static void MultiWordSub(const unsigned int u1[], const unsigned int u2[],
                         unsigned int y[], int n);

namespace coder {
static void b_abs(const array<double, 2U> &x, array<double, 2U> &y);

static double combineVectorElements(const array<double, 2U> &x);

static void detrend(const array<double, 2U> &x, array<double, 2U> &y);

static void do_vectors(const array<int, 1U> &a, const array<int, 1U> &b,
                       array<int, 1U> &c, array<int, 1U> &ia,
                       array<int, 1U> &ib);

static double dot(const double a_data[], const int a_size[2],
                  const array<double, 2U> &b);

static void filter(const array<double, 2U> &x, array<double, 2U> &y);

static void findpeaks(const array<double, 2U> &Yin, array<double, 2U> &Ypk,
                      array<double, 2U> &Xpk);

namespace internal {
namespace blas {
static double xnrm2(int n, const array<double, 2U> &x, int ix0);

}
static int64m_T i64ddiv(const int64m_T x);

namespace lapack {
static int xgeqp3(array<double, 2U> &A, double tau_data[], int jpvt[2]);

}
static double maximum(const array<double, 2U> &x);

} // namespace internal
static void interp1(const array<double, 2U> &varargin_1,
                    const array<double, 2U> &varargin_2,
                    const array<double, 2U> &varargin_3, array<double, 2U> &Vq);

static void interp1(const array<double, 2U> &varargin_1,
                    const array<double, 2U> &varargin_2,
                    const double varargin_3[100], double Vq[100]);

static void linspace(double d1, double d2, const int64m_T n,
                     array<double, 2U> &y);

static void linspace(double d2, double y[100]);

static void pchip(const array<double, 2U> &x, const array<double, 2U> &y,
                  array<double, 2U> &v_breaks, array<double, 2U> &v_coefs);

static double ppval(const array<double, 2U> &pp_breaks,
                    const array<double, 2U> &pp_coefs, double x);

} // namespace coder
static void minus(coder::array<double, 1U> &in1,
                  const coder::array<double, 1U> &in2);

static double sMultiWord2Double(const unsigned int u1[]);

static void sMultiWord2MultiWord(const unsigned int u1[], unsigned int y[],
                                 int n);

static void sMultiWord2sMultiWordSat(const unsigned int u1[], unsigned int y[]);

static int sMultiWordCmp(const unsigned int u1[], const unsigned int u2[]);

static bool sMultiWordGt(const unsigned int u1[], const unsigned int u2[]);

static bool sMultiWordLt(const unsigned int u1[], const unsigned int u2[]);

static void sMultiWordMul(const unsigned int u1[], const unsigned int u2[],
                          unsigned int y[]);

static void uMultiWord2MultiWord(const unsigned int u1[], int n1,
                                 unsigned int y[]);

static int uMultiWordCmp(const unsigned int u1[], const unsigned int u2[]);

static int uMultiWordDiv(unsigned int a[], unsigned int b[], unsigned int q[],
                         unsigned int r[]);

static void uMultiWordDivZero(const unsigned int u1[], const unsigned int u2[],
                              unsigned int b_y1[], unsigned int y2[],
                              unsigned int t1[], unsigned int t2[]);

static bool uMultiWordEq(const unsigned int u1[], const unsigned int u2[]);

static bool uMultiWordGe(const unsigned int u1[], const unsigned int u2[]);

static bool uMultiWordGt(const unsigned int u1[], const unsigned int u2[]);

static bool uMultiWordLe(const unsigned int u1[], const unsigned int u2[]);

static void uMultiWordMul(const unsigned int u1[], const unsigned int u2[],
                          unsigned int y[]);

static void uMultiWordShl(const unsigned int u1[], unsigned int n2,
                          unsigned int y[]);

static void uMultiWordShr(const unsigned int u1[], unsigned int n2,
                          unsigned int y[]);

// Function Definitions
namespace coder {
namespace internal {
namespace fft {
void FFTImplementationCallback::doHalfLengthBluestein(
    const double x[100], creal_T y[100], const creal_T wwc[99],
    const double costabinv[129], const double sintabinv[129])
{
  static const creal_T reconVar1[50]{{
                                         1.0, // re
                                         -1.0 // im
                                     },
                                     {
                                         0.93720948047068664, // re
                                         -0.99802672842827156 // im
                                     },
                                     {
                                         0.87466676643569574, // re
                                         -0.99211470131447788 // im
                                     },
                                     {
                                         0.8126186854142754,  // re
                                         -0.98228725072868872 // im
                                     },
                                     {
                                         0.75131011283514515, // re
                                         -0.96858316112863108 // im
                                     },
                                     {
                                         0.69098300562505255, // re
                                         -0.95105651629515353 // im
                                     },
                                     {
                                         0.63187544731532208, // re
                                         -0.92977648588825135 // im
                                     },
                                     {
                                         0.57422070843492734, // re
                                         -0.90482705246601947 // im
                                     },
                                     {
                                         0.51824632589828468, // re
                                         -0.87630668004386358 // im
                                     },
                                     {
                                         0.46417320502100334, // re
                                         -0.84432792550201508 // im
                                     },
                                     {
                                         0.41221474770752686, // re
                                         -0.80901699437494745 // im
                                     },
                                     {
                                         0.36257601025131025, // re
                                         -0.77051324277578914 // im
                                     },
                                     {
                                         0.31545289407131127, // re
                                         -0.72896862742141155 // im
                                     },
                                     {
                                         0.27103137257858845, // re
                                         -0.68454710592868873 // im
                                     },
                                     {
                                         0.22948675722421086, // re
                                         -0.63742398974868975 // im
                                     },
                                     {
                                         0.19098300562505255, // re
                                         -0.58778525229247314 // im
                                     },
                                     {
                                         0.15567207449798492, // re
                                         -0.53582679497899666 // im
                                     },
                                     {
                                         0.12369331995613642, // re
                                         -0.48175367410171532 // im
                                     },
                                     {
                                         0.095172947533980534, // re
                                         -0.42577929156507272  // im
                                     },
                                     {
                                         0.070223514111748653, // re
                                         -0.368124552684678    // im
                                     },
                                     {
                                         0.048943483704846469, // re
                                         -0.3090169943749474   // im
                                     },
                                     {
                                         0.031416838871368924, // re
                                         -0.24868988716485479  // im
                                     },
                                     {
                                         0.017712749271311279, // re
                                         -0.18738131458572463  // im
                                     },
                                     {
                                         0.0078852986855221241, // re
                                         -0.12533323356430426   // im
                                     },
                                     {
                                         0.001973271571728441, // re
                                         -0.062790519529313374 // im
                                     },
                                     {
                                         0.0, // re
                                         -0.0 // im
                                     },
                                     {
                                         0.001973271571728441, // re
                                         0.062790519529313374  // im
                                     },
                                     {
                                         0.0078852986855221241, // re
                                         0.12533323356430426    // im
                                     },
                                     {
                                         0.017712749271311279, // re
                                         0.18738131458572463   // im
                                     },
                                     {
                                         0.031416838871368924, // re
                                         0.24868988716485479   // im
                                     },
                                     {
                                         0.048943483704846469, // re
                                         0.3090169943749474    // im
                                     },
                                     {
                                         0.070223514111748653, // re
                                         0.368124552684678     // im
                                     },
                                     {
                                         0.095172947533980534, // re
                                         0.42577929156507272   // im
                                     },
                                     {
                                         0.12369331995613642, // re
                                         0.48175367410171532  // im
                                     },
                                     {
                                         0.15567207449798492, // re
                                         0.53582679497899666  // im
                                     },
                                     {
                                         0.19098300562505255, // re
                                         0.58778525229247314  // im
                                     },
                                     {
                                         0.22948675722421086, // re
                                         0.63742398974868975  // im
                                     },
                                     {
                                         0.27103137257858845, // re
                                         0.68454710592868873  // im
                                     },
                                     {
                                         0.31545289407131127, // re
                                         0.72896862742141155  // im
                                     },
                                     {
                                         0.36257601025131025, // re
                                         0.77051324277578914  // im
                                     },
                                     {
                                         0.41221474770752686, // re
                                         0.80901699437494745  // im
                                     },
                                     {
                                         0.46417320502100334, // re
                                         0.84432792550201508  // im
                                     },
                                     {
                                         0.51824632589828468, // re
                                         0.87630668004386358  // im
                                     },
                                     {
                                         0.57422070843492734, // re
                                         0.90482705246601947  // im
                                     },
                                     {
                                         0.63187544731532208, // re
                                         0.92977648588825135  // im
                                     },
                                     {
                                         0.69098300562505255, // re
                                         0.95105651629515353  // im
                                     },
                                     {
                                         0.75131011283514515, // re
                                         0.96858316112863108  // im
                                     },
                                     {
                                         0.8126186854142754, // re
                                         0.98228725072868872 // im
                                     },
                                     {
                                         0.87466676643569574, // re
                                         0.99211470131447788  // im
                                     },
                                     {
                                         0.93720948047068664, // re
                                         0.99802672842827156  // im
                                     }};
  static const creal_T reconVar2[50]{{
                                         1.0, // re
                                         1.0  // im
                                     },
                                     {
                                         1.0627905195293135, // re
                                         0.99802672842827156 // im
                                     },
                                     {
                                         1.1253332335643043, // re
                                         0.99211470131447788 // im
                                     },
                                     {
                                         1.1873813145857246, // re
                                         0.98228725072868872 // im
                                     },
                                     {
                                         1.2486898871648549, // re
                                         0.96858316112863108 // im
                                     },
                                     {
                                         1.3090169943749475, // re
                                         0.95105651629515353 // im
                                     },
                                     {
                                         1.3681245526846779, // re
                                         0.92977648588825135 // im
                                     },
                                     {
                                         1.4257792915650727, // re
                                         0.90482705246601947 // im
                                     },
                                     {
                                         1.4817536741017152, // re
                                         0.87630668004386358 // im
                                     },
                                     {
                                         1.5358267949789965, // re
                                         0.84432792550201508 // im
                                     },
                                     {
                                         1.5877852522924731, // re
                                         0.80901699437494745 // im
                                     },
                                     {
                                         1.6374239897486897, // re
                                         0.77051324277578914 // im
                                     },
                                     {
                                         1.6845471059286887, // re
                                         0.72896862742141155 // im
                                     },
                                     {
                                         1.7289686274214116, // re
                                         0.68454710592868873 // im
                                     },
                                     {
                                         1.770513242775789,  // re
                                         0.63742398974868975 // im
                                     },
                                     {
                                         1.8090169943749475, // re
                                         0.58778525229247314 // im
                                     },
                                     {
                                         1.8443279255020151, // re
                                         0.53582679497899666 // im
                                     },
                                     {
                                         1.8763066800438635, // re
                                         0.48175367410171532 // im
                                     },
                                     {
                                         1.9048270524660196, // re
                                         0.42577929156507272 // im
                                     },
                                     {
                                         1.9297764858882513, // re
                                         0.368124552684678   // im
                                     },
                                     {
                                         1.9510565162951536, // re
                                         0.3090169943749474  // im
                                     },
                                     {
                                         1.9685831611286311, // re
                                         0.24868988716485479 // im
                                     },
                                     {
                                         1.9822872507286888, // re
                                         0.18738131458572463 // im
                                     },
                                     {
                                         1.992114701314478,  // re
                                         0.12533323356430426 // im
                                     },
                                     {
                                         1.9980267284282716,  // re
                                         0.062790519529313374 // im
                                     },
                                     {
                                         2.0, // re
                                         0.0  // im
                                     },
                                     {
                                         1.9980267284282716,   // re
                                         -0.062790519529313374 // im
                                     },
                                     {
                                         1.992114701314478,   // re
                                         -0.12533323356430426 // im
                                     },
                                     {
                                         1.9822872507286888,  // re
                                         -0.18738131458572463 // im
                                     },
                                     {
                                         1.9685831611286311,  // re
                                         -0.24868988716485479 // im
                                     },
                                     {
                                         1.9510565162951536, // re
                                         -0.3090169943749474 // im
                                     },
                                     {
                                         1.9297764858882513, // re
                                         -0.368124552684678  // im
                                     },
                                     {
                                         1.9048270524660196,  // re
                                         -0.42577929156507272 // im
                                     },
                                     {
                                         1.8763066800438635,  // re
                                         -0.48175367410171532 // im
                                     },
                                     {
                                         1.8443279255020151,  // re
                                         -0.53582679497899666 // im
                                     },
                                     {
                                         1.8090169943749475,  // re
                                         -0.58778525229247314 // im
                                     },
                                     {
                                         1.770513242775789,   // re
                                         -0.63742398974868975 // im
                                     },
                                     {
                                         1.7289686274214116,  // re
                                         -0.68454710592868873 // im
                                     },
                                     {
                                         1.6845471059286887,  // re
                                         -0.72896862742141155 // im
                                     },
                                     {
                                         1.6374239897486897,  // re
                                         -0.77051324277578914 // im
                                     },
                                     {
                                         1.5877852522924731,  // re
                                         -0.80901699437494745 // im
                                     },
                                     {
                                         1.5358267949789965,  // re
                                         -0.84432792550201508 // im
                                     },
                                     {
                                         1.4817536741017152,  // re
                                         -0.87630668004386358 // im
                                     },
                                     {
                                         1.4257792915650727,  // re
                                         -0.90482705246601947 // im
                                     },
                                     {
                                         1.3681245526846779,  // re
                                         -0.92977648588825135 // im
                                     },
                                     {
                                         1.3090169943749475,  // re
                                         -0.95105651629515353 // im
                                     },
                                     {
                                         1.2486898871648549,  // re
                                         -0.96858316112863108 // im
                                     },
                                     {
                                         1.1873813145857246,  // re
                                         -0.98228725072868872 // im
                                     },
                                     {
                                         1.1253332335643043,  // re
                                         -0.99211470131447788 // im
                                     },
                                     {
                                         1.0627905195293135,  // re
                                         -0.99802672842827156 // im
                                     }};
  static const double b_dv[129]{0.0,
                                -0.024541228522912288,
                                -0.049067674327418015,
                                -0.073564563599667426,
                                -0.0980171403295606,
                                -0.1224106751992162,
                                -0.14673047445536175,
                                -0.17096188876030122,
                                -0.19509032201612825,
                                -0.2191012401568698,
                                -0.24298017990326387,
                                -0.26671275747489837,
                                -0.29028467725446233,
                                -0.31368174039889152,
                                -0.33688985339222005,
                                -0.35989503653498811,
                                -0.38268343236508978,
                                -0.40524131400498986,
                                -0.42755509343028208,
                                -0.44961132965460654,
                                -0.47139673682599764,
                                -0.49289819222978404,
                                -0.51410274419322166,
                                -0.53499761988709715,
                                -0.55557023301960218,
                                -0.57580819141784534,
                                -0.59569930449243336,
                                -0.61523159058062682,
                                -0.63439328416364549,
                                -0.65317284295377676,
                                -0.67155895484701833,
                                -0.68954054473706683,
                                -0.70710678118654757,
                                -0.724247082951467,
                                -0.74095112535495922,
                                -0.75720884650648457,
                                -0.773010453362737,
                                -0.78834642762660634,
                                -0.80320753148064494,
                                -0.81758481315158371,
                                -0.83146961230254524,
                                -0.84485356524970712,
                                -0.85772861000027212,
                                -0.87008699110871146,
                                -0.881921264348355,
                                -0.89322430119551532,
                                -0.90398929312344334,
                                -0.91420975570353069,
                                -0.92387953251128674,
                                -0.932992798834739,
                                -0.94154406518302081,
                                -0.94952818059303667,
                                -0.95694033573220882,
                                -0.96377606579543984,
                                -0.970031253194544,
                                -0.97570213003852857,
                                -0.98078528040323043,
                                -0.98527764238894122,
                                -0.989176509964781,
                                -0.99247953459871,
                                -0.99518472667219693,
                                -0.99729045667869021,
                                -0.99879545620517241,
                                -0.99969881869620425,
                                -1.0,
                                -0.99969881869620425,
                                -0.99879545620517241,
                                -0.99729045667869021,
                                -0.99518472667219693,
                                -0.99247953459871,
                                -0.989176509964781,
                                -0.98527764238894122,
                                -0.98078528040323043,
                                -0.97570213003852857,
                                -0.970031253194544,
                                -0.96377606579543984,
                                -0.95694033573220882,
                                -0.94952818059303667,
                                -0.94154406518302081,
                                -0.932992798834739,
                                -0.92387953251128674,
                                -0.91420975570353069,
                                -0.90398929312344334,
                                -0.89322430119551532,
                                -0.881921264348355,
                                -0.87008699110871146,
                                -0.85772861000027212,
                                -0.84485356524970712,
                                -0.83146961230254524,
                                -0.81758481315158371,
                                -0.80320753148064494,
                                -0.78834642762660634,
                                -0.773010453362737,
                                -0.75720884650648457,
                                -0.74095112535495922,
                                -0.724247082951467,
                                -0.70710678118654757,
                                -0.68954054473706683,
                                -0.67155895484701833,
                                -0.65317284295377676,
                                -0.63439328416364549,
                                -0.61523159058062682,
                                -0.59569930449243336,
                                -0.57580819141784534,
                                -0.55557023301960218,
                                -0.53499761988709715,
                                -0.51410274419322166,
                                -0.49289819222978404,
                                -0.47139673682599764,
                                -0.44961132965460654,
                                -0.42755509343028208,
                                -0.40524131400498986,
                                -0.38268343236508978,
                                -0.35989503653498811,
                                -0.33688985339222005,
                                -0.31368174039889152,
                                -0.29028467725446233,
                                -0.26671275747489837,
                                -0.24298017990326387,
                                -0.2191012401568698,
                                -0.19509032201612825,
                                -0.17096188876030122,
                                -0.14673047445536175,
                                -0.1224106751992162,
                                -0.0980171403295606,
                                -0.073564563599667426,
                                -0.049067674327418015,
                                -0.024541228522912288,
                                -0.0};
  static const signed char iv[50]{
      1,  50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35,
      34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18,
      17, 16, 15, 14, 13, 12, 11, 10, 9,  8,  7,  6,  5,  4,  3,  2};
  creal_T fv[128];
  creal_T fy[128];
  creal_T ytmp[50];
  double hcostab[64];
  double hcostabinv[64];
  double hsintab[64];
  double hsintabinv[64];
  double b_temp_re_tmp;
  double temp_im;
  double temp_re;
  double twid_im;
  double twid_re;
  double ytmp_re_tmp;
  int i;
  int iheight;
  int ihi;
  int istart;
  int iy;
  int ju;
  int k;
  int temp_re_tmp;
  bool tst;
  for (i = 0; i < 64; i++) {
    iy = ((i + 1) << 1) - 2;
    hcostab[i] = dv[iy];
    hsintab[i] = b_dv[iy];
    hcostabinv[i] = costabinv[iy];
    hsintabinv[i] = sintabinv[iy];
  }
  for (iy = 0; iy < 50; iy++) {
    temp_re_tmp = iy << 1;
    temp_re = x[temp_re_tmp];
    temp_im = x[temp_re_tmp + 1];
    ytmp_re_tmp = wwc[iy + 49].re;
    twid_re = wwc[iy + 49].im;
    ytmp[iy].re = ytmp_re_tmp * temp_re + twid_re * temp_im;
    ytmp[iy].im = ytmp_re_tmp * temp_im - twid_re * temp_re;
  }
  std::memset(&fy[0], 0, 128U * sizeof(creal_T));
  iy = 0;
  ju = 0;
  for (i = 0; i < 49; i++) {
    fy[iy] = ytmp[i];
    iy = 128;
    tst = true;
    while (tst) {
      iy >>= 1;
      ju ^= iy;
      tst = ((ju & iy) == 0);
    }
    iy = ju;
  }
  fy[iy] = ytmp[49];
  for (i = 0; i <= 126; i += 2) {
    b_temp_re_tmp = fy[i + 1].re;
    ytmp_re_tmp = fy[i + 1].im;
    temp_im = ytmp_re_tmp;
    temp_re = fy[i].re;
    twid_im = fy[i].im;
    fy[i + 1].re = temp_re - b_temp_re_tmp;
    ytmp_re_tmp = twid_im - ytmp_re_tmp;
    fy[i + 1].im = ytmp_re_tmp;
    fy[i].re = temp_re + b_temp_re_tmp;
    fy[i].im = twid_im + temp_im;
  }
  iy = 2;
  ju = 4;
  k = 32;
  iheight = 125;
  while (k > 0) {
    for (i = 0; i < iheight; i += ju) {
      temp_re_tmp = i + iy;
      temp_re = fy[temp_re_tmp].re;
      temp_im = fy[temp_re_tmp].im;
      fy[temp_re_tmp].re = fy[i].re - temp_re;
      fy[temp_re_tmp].im = fy[i].im - temp_im;
      fy[i].re += temp_re;
      fy[i].im += temp_im;
    }
    istart = 1;
    for (int j{k}; j < 64; j += k) {
      twid_re = hcostab[j];
      twid_im = hsintab[j];
      i = istart;
      ihi = istart + iheight;
      while (i < ihi) {
        temp_re_tmp = i + iy;
        b_temp_re_tmp = fy[temp_re_tmp].im;
        temp_im = fy[temp_re_tmp].re;
        temp_re = twid_re * temp_im - twid_im * b_temp_re_tmp;
        temp_im = twid_re * b_temp_re_tmp + twid_im * temp_im;
        fy[temp_re_tmp].re = fy[i].re - temp_re;
        fy[temp_re_tmp].im = fy[i].im - temp_im;
        fy[i].re += temp_re;
        fy[i].im += temp_im;
        i += ju;
      }
      istart++;
    }
    k /= 2;
    iy = ju;
    ju += ju;
    iheight -= iy;
  }
  std::memset(&fv[0], 0, 128U * sizeof(creal_T));
  iy = 0;
  ju = 0;
  for (i = 0; i < 98; i++) {
    fv[iy] = wwc[i];
    iy = 128;
    tst = true;
    while (tst) {
      iy >>= 1;
      ju ^= iy;
      tst = ((ju & iy) == 0);
    }
    iy = ju;
  }
  fv[iy] = wwc[98];
  for (i = 0; i <= 126; i += 2) {
    b_temp_re_tmp = fv[i + 1].re;
    ytmp_re_tmp = fv[i + 1].im;
    temp_im = ytmp_re_tmp;
    temp_re = fv[i].re;
    twid_im = fv[i].im;
    fv[i + 1].re = temp_re - b_temp_re_tmp;
    ytmp_re_tmp = twid_im - ytmp_re_tmp;
    fv[i + 1].im = ytmp_re_tmp;
    fv[i].re = temp_re + b_temp_re_tmp;
    fv[i].im = twid_im + temp_im;
  }
  iy = 2;
  ju = 4;
  k = 32;
  iheight = 125;
  while (k > 0) {
    for (i = 0; i < iheight; i += ju) {
      temp_re_tmp = i + iy;
      temp_re = fv[temp_re_tmp].re;
      temp_im = fv[temp_re_tmp].im;
      fv[temp_re_tmp].re = fv[i].re - temp_re;
      fv[temp_re_tmp].im = fv[i].im - temp_im;
      fv[i].re += temp_re;
      fv[i].im += temp_im;
    }
    istart = 1;
    for (int j{k}; j < 64; j += k) {
      twid_re = hcostab[j];
      twid_im = hsintab[j];
      i = istart;
      ihi = istart + iheight;
      while (i < ihi) {
        temp_re_tmp = i + iy;
        b_temp_re_tmp = fv[temp_re_tmp].im;
        temp_im = fv[temp_re_tmp].re;
        temp_re = twid_re * temp_im - twid_im * b_temp_re_tmp;
        temp_im = twid_re * b_temp_re_tmp + twid_im * temp_im;
        fv[temp_re_tmp].re = fv[i].re - temp_re;
        fv[temp_re_tmp].im = fv[i].im - temp_im;
        fv[i].re += temp_re;
        fv[i].im += temp_im;
        i += ju;
      }
      istart++;
    }
    k /= 2;
    iy = ju;
    ju += ju;
    iheight -= iy;
  }
  for (iy = 0; iy < 128; iy++) {
    temp_re = fy[iy].re;
    twid_im = fv[iy].im;
    temp_im = fy[iy].im;
    twid_re = fv[iy].re;
    fy[iy].re = temp_re * twid_re - temp_im * twid_im;
    fy[iy].im = temp_re * twid_im + temp_im * twid_re;
  }
  iy = 0;
  ju = 0;
  for (i = 0; i < 127; i++) {
    fv[iy] = fy[i];
    iy = 128;
    tst = true;
    while (tst) {
      iy >>= 1;
      ju ^= iy;
      tst = ((ju & iy) == 0);
    }
    iy = ju;
  }
  fv[iy] = fy[127];
  for (i = 0; i <= 126; i += 2) {
    b_temp_re_tmp = fv[i + 1].re;
    ytmp_re_tmp = fv[i + 1].im;
    temp_im = ytmp_re_tmp;
    temp_re = fv[i].re;
    twid_im = fv[i].im;
    fv[i + 1].re = temp_re - b_temp_re_tmp;
    ytmp_re_tmp = twid_im - ytmp_re_tmp;
    fv[i + 1].im = ytmp_re_tmp;
    fv[i].re = temp_re + b_temp_re_tmp;
    fv[i].im = twid_im + temp_im;
  }
  iy = 2;
  ju = 4;
  k = 32;
  iheight = 125;
  while (k > 0) {
    for (i = 0; i < iheight; i += ju) {
      temp_re_tmp = i + iy;
      temp_re = fv[temp_re_tmp].re;
      temp_im = fv[temp_re_tmp].im;
      fv[temp_re_tmp].re = fv[i].re - temp_re;
      fv[temp_re_tmp].im = fv[i].im - temp_im;
      fv[i].re += temp_re;
      fv[i].im += temp_im;
    }
    istart = 1;
    for (int j{k}; j < 64; j += k) {
      twid_re = hcostabinv[j];
      twid_im = hsintabinv[j];
      i = istart;
      ihi = istart + iheight;
      while (i < ihi) {
        temp_re_tmp = i + iy;
        b_temp_re_tmp = fv[temp_re_tmp].im;
        temp_im = fv[temp_re_tmp].re;
        temp_re = twid_re * temp_im - twid_im * b_temp_re_tmp;
        temp_im = twid_re * b_temp_re_tmp + twid_im * temp_im;
        fv[temp_re_tmp].re = fv[i].re - temp_re;
        fv[temp_re_tmp].im = fv[i].im - temp_im;
        fv[i].re += temp_re;
        fv[i].im += temp_im;
        i += ju;
      }
      istart++;
    }
    k /= 2;
    iy = ju;
    ju += ju;
    iheight -= iy;
  }
  for (iy = 0; iy < 128; iy++) {
    fv[iy].re *= 0.0078125;
    fv[iy].im *= 0.0078125;
  }
  for (k = 0; k < 50; k++) {
    ytmp_re_tmp = wwc[k + 49].re;
    twid_re = fv[k + 49].im;
    twid_im = wwc[k + 49].im;
    temp_im = fv[k + 49].re;
    ytmp[k].re = ytmp_re_tmp * temp_im + twid_im * twid_re;
    ytmp[k].im = ytmp_re_tmp * twid_re - twid_im * temp_im;
  }
  for (i = 0; i < 50; i++) {
    double b_ytmp_re_tmp;
    double c_ytmp_re_tmp;
    temp_im = ytmp[i].re;
    twid_re = reconVar1[i].im;
    twid_im = ytmp[i].im;
    temp_re = reconVar1[i].re;
    iy = iv[i] - 1;
    ytmp_re_tmp = ytmp[iy].re;
    b_temp_re_tmp = -ytmp[iy].im;
    b_ytmp_re_tmp = reconVar2[i].im;
    c_ytmp_re_tmp = reconVar2[i].re;
    y[i].re =
        0.5 * ((temp_im * temp_re - twid_im * twid_re) +
               (ytmp_re_tmp * c_ytmp_re_tmp - b_temp_re_tmp * b_ytmp_re_tmp));
    y[i].im =
        0.5 * ((temp_im * twid_re + twid_im * temp_re) +
               (ytmp_re_tmp * b_ytmp_re_tmp + b_temp_re_tmp * c_ytmp_re_tmp));
    y[i + 50].re = 0.5 * ((temp_im * c_ytmp_re_tmp - twid_im * b_ytmp_re_tmp) +
                          (ytmp_re_tmp * temp_re - b_temp_re_tmp * twid_re));
    y[i + 50].im = 0.5 * ((temp_im * b_ytmp_re_tmp + twid_im * c_ytmp_re_tmp) +
                          (ytmp_re_tmp * twid_re + b_temp_re_tmp * temp_re));
  }
}

} // namespace fft
} // namespace internal
} // namespace coder
static int MultiWord2sLong(const unsigned int u[])
{
  return static_cast<int>(u[0]);
}

static void MultiWordAdd(const unsigned int u1[], const unsigned int u2[],
                         unsigned int y[])
{
  int carry{0};
  for (int i{0}; i < 2; i++) {
    unsigned int u1i;
    unsigned int yi;
    u1i = u1[i];
    yi = (u1i + u2[i]) + static_cast<unsigned int>(carry);
    y[i] = yi;
    if (carry != 0) {
      carry = (yi <= u1i);
    } else {
      carry = (yi < u1i);
    }
  }
}

static void MultiWordNeg(const unsigned int u1[], unsigned int y[])
{
  int carry{1};
  for (int i{0}; i < 2; i++) {
    unsigned int yi;
    yi = ~u1[i] + static_cast<unsigned int>(carry);
    y[i] = yi;
    carry = (yi < static_cast<unsigned int>(carry));
  }
}

static void MultiWordSetUnsignedMax(unsigned int y[])
{
  for (int i{0}; i < 2; i++) {
    y[i] = MAX_uint32_T;
  }
}

static void MultiWordSub(const unsigned int u1[], const unsigned int u2[],
                         unsigned int y[], int n)
{
  int borrow{0};
  for (int i{0}; i < n; i++) {
    unsigned int u1i;
    unsigned int yi;
    u1i = u1[i];
    yi = (u1i - u2[i]) - static_cast<unsigned int>(borrow);
    y[i] = yi;
    if (borrow != 0) {
      borrow = (yi >= u1i);
    } else {
      borrow = (yi > u1i);
    }
  }
}

namespace coder {
static void b_abs(const array<double, 2U> &x, array<double, 2U> &y)
{
  int nx_tmp;
  nx_tmp = x.size(1);
  y.set_size(1, x.size(1));
  for (int k{0}; k < nx_tmp; k++) {
    y[k] = std::abs(x[k]);
  }
}

static double combineVectorElements(const array<double, 2U> &x)
{
  double y;
  if (x.size(1) == 0) {
    y = 0.0;
  } else {
    int firstBlockLength;
    int lastBlockLength;
    int nblocks;
    if (x.size(1) <= 1024) {
      firstBlockLength = x.size(1);
      lastBlockLength = 0;
      nblocks = 1;
    } else {
      firstBlockLength = 1024;
      nblocks = static_cast<int>(static_cast<unsigned int>(x.size(1)) >> 10);
      lastBlockLength = x.size(1) - (nblocks << 10);
      if (lastBlockLength > 0) {
        nblocks++;
      } else {
        lastBlockLength = 1024;
      }
    }
    y = x[0];
    for (int k{2}; k <= firstBlockLength; k++) {
      y += x[k - 1];
    }
    for (int ib{2}; ib <= nblocks; ib++) {
      double bsum;
      int hi;
      firstBlockLength = (ib - 1) << 10;
      bsum = x[firstBlockLength];
      if (ib == nblocks) {
        hi = lastBlockLength;
      } else {
        hi = 1024;
      }
      for (int k{2}; k <= hi; k++) {
        bsum += x[(firstBlockLength + k) - 1];
      }
      y += bsum;
    }
  }
  return y;
}

static void detrend(const array<double, 2U> &x, array<double, 2U> &y)
{
  array<double, 2U> A;
  array<double, 2U> W;
  array<double, 1U> a;
  array<double, 1U> b_y1;
  array<double, 1U> sOriginalType;
  array<int, 2U> b_y;
  double tau_data[2];
  int i;
  int loop_ub;
  int maxmn;
  int n_tmp;
  int yk;
  loop_ub = x.size(1);
  b_y1.set_size(x.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_y1[i] = x[i];
  }
  if (b_y1.size(0) - 1 < 0) {
    n_tmp = 0;
  } else {
    n_tmp = b_y1.size(0);
  }
  b_y.set_size(1, n_tmp);
  if (n_tmp > 0) {
    b_y[0] = 0;
    yk = 0;
    for (maxmn = 2; maxmn <= n_tmp; maxmn++) {
      yk++;
      b_y[maxmn - 1] = yk;
    }
  }
  sOriginalType.set_size(n_tmp);
  for (i = 0; i < n_tmp; i++) {
    sOriginalType[i] = b_y[i];
  }
  if (b_y1.size(0) != 0) {
    if (b_y1.size(0) == 1) {
      b_y1[0] = b_y1[0] * 0.0;
    } else {
      double p[2];
      double tol;
      int jpvt[2];
      int rr;
      a.set_size(n_tmp);
      for (int b_i{0}; b_i < n_tmp; b_i++) {
        a[b_i] = sOriginalType[b_i] - sOriginalType[0];
      }
      for (i = 0; i < n_tmp; i++) {
        a[i] = a[i] / sOriginalType[sOriginalType.size(0) - 1];
      }
      W.set_size(n_tmp, 2);
      for (int b_i{0}; b_i < n_tmp; b_i++) {
        tol = a[b_i];
        tol = std::fmax(tol, 0.0);
        a[b_i] = tol;
        W[b_i] = tol;
        W[b_i + W.size(0)] = 1.0;
      }
      A.set_size(n_tmp, 2);
      yk = W.size(0) << 1;
      for (i = 0; i < yk; i++) {
        A[i] = W[i];
      }
      internal::lapack::xgeqp3(A, tau_data, jpvt);
      rr = 0;
      if (A.size(0) < 2) {
        yk = A.size(0);
        maxmn = 2;
      } else {
        yk = 2;
        maxmn = A.size(0);
      }
      if (yk > 0) {
        tol = std::fmin(1.4901161193847656E-8,
                        2.2204460492503131E-15 * static_cast<double>(maxmn)) *
              std::abs(A[0]);
        while ((rr < yk) && (!(std::abs(A[rr + A.size(0) * rr]) <= tol))) {
          rr++;
        }
      }
      sOriginalType.set_size(x.size(1));
      for (i = 0; i < loop_ub; i++) {
        sOriginalType[i] = b_y1[i];
      }
      p[0] = 0.0;
      p[1] = 0.0;
      yk = A.size(0);
      if (yk > 2) {
        yk = 2;
      }
      for (int j{0}; j < yk; j++) {
        maxmn = A.size(0);
        if (tau_data[j] != 0.0) {
          tol = sOriginalType[j];
          i = j + 2;
          for (int b_i{i}; b_i <= maxmn; b_i++) {
            tol += A[(b_i + A.size(0) * j) - 1] * sOriginalType[b_i - 1];
          }
          tol *= tau_data[j];
          if (tol != 0.0) {
            sOriginalType[j] = sOriginalType[j] - tol;
            for (int b_i{i}; b_i <= maxmn; b_i++) {
              sOriginalType[b_i - 1] =
                  sOriginalType[b_i - 1] - A[(b_i + A.size(0) * j) - 1] * tol;
            }
          }
        }
      }
      for (int b_i{0}; b_i < rr; b_i++) {
        p[jpvt[b_i] - 1] = sOriginalType[b_i];
      }
      for (int j{rr}; j >= 1; j--) {
        yk = jpvt[j - 1] - 1;
        p[yk] /= A[(j + A.size(0) * (j - 1)) - 1];
        for (int b_i{0}; b_i <= j - 2; b_i++) {
          p[jpvt[0] - 1] -= p[yk] * A[A.size(0) * (j - 1)];
        }
      }
      sOriginalType.set_size(n_tmp);
      for (int b_i{0}; b_i < n_tmp; b_i++) {
        sOriginalType[b_i] = W[b_i] * p[0] + W[W.size(0) + b_i] * p[1];
      }
      if (b_y1.size(0) == sOriginalType.size(0)) {
        for (i = 0; i < loop_ub; i++) {
          b_y1[i] = b_y1[i] - sOriginalType[i];
        }
      } else {
        minus(b_y1, sOriginalType);
      }
    }
  }
  loop_ub = b_y1.size(0);
  y.set_size(1, b_y1.size(0));
  for (i = 0; i < loop_ub; i++) {
    y[i] = b_y1[i];
  }
}

static void do_vectors(const array<int, 1U> &a, const array<int, 1U> &b,
                       array<int, 1U> &c, array<int, 1U> &ia,
                       array<int, 1U> &ib)
{
  int b_ialast;
  int b_iblast;
  int i;
  int iafirst;
  int ialast;
  int ibfirst;
  int iblast;
  int nb_tmp;
  int nc;
  int ncmax;
  int nia;
  int nib;
  i = a.size(0);
  nb_tmp = b.size(0);
  ncmax = a.size(0) + b.size(0);
  c.set_size(ncmax);
  ia.set_size(a.size(0));
  ib.set_size(b.size(0));
  nc = -1;
  nia = -1;
  nib = 0;
  iafirst = 1;
  ialast = 0;
  ibfirst = 0;
  iblast = 0;
  while ((ialast + 1 <= i) && (iblast + 1 <= nb_tmp)) {
    int ak;
    int bk;
    b_ialast = ialast + 1;
    ak = a[ialast];
    while ((b_ialast < a.size(0)) && (a[b_ialast] == ak)) {
      b_ialast++;
    }
    ialast = b_ialast - 1;
    b_iblast = iblast + 1;
    bk = b[iblast];
    while ((b_iblast < b.size(0)) && (b[b_iblast] == bk)) {
      b_iblast++;
    }
    iblast = b_iblast - 1;
    if (ak == bk) {
      nc++;
      c[nc] = ak;
      nia++;
      ia[nia] = iafirst;
      ialast = b_ialast;
      iafirst = b_ialast + 1;
      iblast = b_iblast;
      ibfirst = b_iblast;
    } else if (ak < bk) {
      nc++;
      nia++;
      c[nc] = ak;
      ia[nia] = iafirst;
      ialast = b_ialast;
      iafirst = b_ialast + 1;
    } else {
      nc++;
      nib++;
      c[nc] = bk;
      ib[nib - 1] = ibfirst + 1;
      iblast = b_iblast;
      ibfirst = b_iblast;
    }
  }
  while (ialast + 1 <= i) {
    b_ialast = ialast + 1;
    while ((b_ialast < a.size(0)) && (a[b_ialast] == a[ialast])) {
      b_ialast++;
    }
    nc++;
    nia++;
    c[nc] = a[ialast];
    ia[nia] = iafirst;
    ialast = b_ialast;
    iafirst = b_ialast + 1;
  }
  while (iblast + 1 <= nb_tmp) {
    b_iblast = iblast + 1;
    while ((b_iblast < b.size(0)) && (b[b_iblast] == b[iblast])) {
      b_iblast++;
    }
    nc++;
    nib++;
    c[nc] = b[iblast];
    ib[nib - 1] = ibfirst + 1;
    iblast = b_iblast;
    ibfirst = b_iblast;
  }
  if (a.size(0) > 0) {
    if (nia + 1 < 1) {
      i = 0;
    } else {
      i = nia + 1;
    }
    ia.set_size(i);
  }
  if (b.size(0) > 0) {
    if (nib < 1) {
      nib = 0;
    }
    ib.set_size(nib);
  }
  if (ncmax > 0) {
    if (nc + 1 < 1) {
      i = 0;
    } else {
      i = nc + 1;
    }
    c.set_size(i);
  }
}

static double dot(const double a_data[], const int a_size[2],
                  const array<double, 2U> &b)
{
  double c;
  c = 0.0;
  if (a_size[1] >= 1) {
    int i;
    i = a_size[1];
    for (int k{0}; k < i; k++) {
      c += a_data[k] * b[k];
    }
  }
  return c;
}

static void filter(const array<double, 2U> &x, array<double, 2U> &y)
{
  array<double, 1U> b;
  array<double, 1U> b_y1;
  int loop_ub;
  int nx_m_nb;
  loop_ub = x.size(1);
  b.set_size(x.size(1));
  for (nx_m_nb = 0; nx_m_nb < loop_ub; nx_m_nb++) {
    b[nx_m_nb] = x[nx_m_nb];
  }
  b_y1.set_size(x.size(1));
  for (nx_m_nb = 0; nx_m_nb < loop_ub; nx_m_nb++) {
    b_y1[nx_m_nb] = 0.0;
  }
  if (b.size(0) >= 80) {
    for (int k{0}; k < 40; k++) {
      nx_m_nb = k + 1;
      for (int j{nx_m_nb}; j <= loop_ub; j++) {
        b_y1[j - 1] = b_y1[j - 1] + 0.025 * b[(j - k) - 1];
      }
    }
  } else {
    int naxpy;
    int y1_tmp;
    if (b.size(0) > 40) {
      nx_m_nb = b.size(0) - 41;
    } else {
      nx_m_nb = -1;
    }
    for (int k{0}; k <= nx_m_nb; k++) {
      for (int j{0}; j < 40; j++) {
        y1_tmp = k + j;
        b_y1[y1_tmp] = b_y1[y1_tmp] + b[k] * 0.025;
      }
    }
    naxpy = b.size(0) - nx_m_nb;
    nx_m_nb += 2;
    for (int k{nx_m_nb}; k <= loop_ub; k++) {
      for (int j{0}; j <= naxpy - 2; j++) {
        y1_tmp = (k + j) - 1;
        b_y1[y1_tmp] = b_y1[y1_tmp] + b[k - 1] * 0.025;
      }
      naxpy--;
    }
  }
  y.set_size(1, x.size(1));
  for (nx_m_nb = 0; nx_m_nb < loop_ub; nx_m_nb++) {
    y[nx_m_nb] = b_y1[nx_m_nb];
  }
}

static void findpeaks(const array<double, 2U> &Yin, array<double, 2U> &Ypk,
                      array<double, 2U> &Xpk)
{
  array<int, 2U> y;
  array<int, 1U> c;
  array<int, 1U> fPk;
  array<int, 1U> iInfinite;
  array<int, 1U> iPk;
  array<int, 1U> idx;
  double ykfirst;
  int i;
  int kfirst;
  int nInf;
  int nPk;
  char dir;
  bool isinfykfirst;
  i = Yin.size(1);
  fPk.set_size(Yin.size(1));
  iInfinite.set_size(Yin.size(1));
  nPk = 0;
  nInf = 0;
  dir = 'n';
  kfirst = 0;
  ykfirst = rtInf;
  isinfykfirst = true;
  for (int k{1}; k <= i; k++) {
    double yk;
    bool isinfyk;
    yk = Yin[k - 1];
    if (std::isnan(yk)) {
      yk = rtInf;
      isinfyk = true;
    } else if (std::isinf(yk) && (yk > 0.0)) {
      isinfyk = true;
      nInf++;
      iInfinite[nInf - 1] = k;
    } else {
      isinfyk = false;
    }
    if (yk != ykfirst) {
      char previousdir;
      previousdir = dir;
      if (isinfyk || isinfykfirst) {
        dir = 'n';
      } else if (yk < ykfirst) {
        dir = 'd';
        if (previousdir == 'i') {
          nPk++;
          fPk[nPk - 1] = kfirst;
        }
      } else {
        dir = 'i';
      }
      ykfirst = yk;
      kfirst = k;
      isinfykfirst = isinfyk;
    }
  }
  if (nPk < 1) {
    i = 0;
  } else {
    i = nPk;
  }
  fPk.set_size(i);
  if (nInf < 1) {
    nInf = 0;
  }
  iInfinite.set_size(nInf);
  iPk.set_size(i);
  nPk = 0;
  for (int k{0}; k < i; k++) {
    ykfirst = Yin[fPk[k] - 1];
    if ((ykfirst > rtMinusInf) &&
        (ykfirst - std::fmax(Yin[fPk[k] - 2], Yin[fPk[k]]) >= 0.0)) {
      nPk++;
      iPk[nPk - 1] = fPk[k];
    }
  }
  if (nPk < 1) {
    nPk = 0;
  }
  iPk.set_size(nPk);
  do_vectors(iPk, iInfinite, c, idx, fPk);
  nInf = c.size(0);
  y.set_size(1, c.size(0));
  if (c.size(0) > 0) {
    y[0] = 1;
    nPk = 1;
    for (int k{2}; k <= nInf; k++) {
      nPk++;
      y[k - 1] = nPk;
    }
  }
  idx.set_size(c.size(0));
  for (i = 0; i < nInf; i++) {
    idx[i] = y[i];
  }
  if (idx.size(0) > Yin.size(1)) {
    fPk.set_size(Yin.size(1));
    idx.set_size(Yin.size(1));
  } else {
    fPk.set_size(c.size(0));
  }
  nPk = fPk.size(0);
  fPk.set_size(nPk);
  for (i = 0; i < nPk; i++) {
    fPk[i] = c[idx[i] - 1];
  }
  Ypk.set_size(1, nPk);
  Xpk.set_size(1, nPk);
  for (i = 0; i < nPk; i++) {
    Ypk[i] = Yin[fPk[i] - 1];
    Xpk[i] = static_cast<unsigned int>(fPk[i]);
  }
}

namespace internal {
namespace blas {
static double xnrm2(int n, const array<double, 2U> &x, int ix0)
{
  double y;
  y = 0.0;
  if (n >= 1) {
    if (n == 1) {
      y = std::abs(x[ix0 - 1]);
    } else {
      double scale;
      int kend;
      scale = 3.3121686421112381E-170;
      kend = ix0 + n;
      for (int k{ix0}; k < kend; k++) {
        double absxk;
        absxk = std::abs(x[k - 1]);
        if (absxk > scale) {
          double t;
          t = scale / absxk;
          y = y * t * t + 1.0;
          scale = absxk;
        } else {
          double t;
          t = absxk / scale;
          y += t * t;
        }
      }
      y = scale * std::sqrt(y);
    }
  }
  return y;
}

} // namespace blas
static int64m_T i64ddiv(const int64m_T x)
{
  static const int64m_T r{
      {0U, 0U} // chunks
  };
  static const int64m_T r13{
      {MAX_uint32_T, 2147483647U} // chunks
  };
  static const int64m_T r2{
      {0U, 2147483648U} // chunks
  };
  static const uint64m_T r10{
      {MAX_uint32_T, 2147483647U} // chunks
  };
  static const uint64m_T r16{
      {1U, 0U} // chunks
  };
  static const uint64m_T r18{
      {MAX_uint32_T, MAX_uint32_T} // chunks
  };
  static const uint64m_T r3{
      {0U, 2147483648U} // chunks
  };
  static const uint64m_T r5{
      {0U, 0U} // chunks
  };
  static const uint64m_T r7{
      {0U, 2048000U} // chunks
  };
  int64m_T r14;
  int64m_T r4;
  int64m_T z;
  uint128m_T r15;
  uint64m_T b_nk_unsgn;
  uint64m_T nk_unsgn;
  uint64m_T r1;
  uint64m_T r11;
  uint64m_T r12;
  uint64m_T r17;
  uint64m_T r19;
  uint64m_T r20;
  uint64m_T r21;
  uint64m_T r22;
  uint64m_T r8;
  uint64m_T r9;
  uint64m_T res;
  uint64m_T t;
  int xexp;
  if (sMultiWordLt((const unsigned int *)&x.chunks[0U],
                   (const unsigned int *)&r.chunks[0U])) {
    if (sMultiWordGt((const unsigned int *)&x.chunks[0U],
                     (const unsigned int *)&r2.chunks[0U])) {
      MultiWordNeg((const unsigned int *)&x.chunks[0U],
                   (unsigned int *)&r4.chunks[0U]);
      sMultiWord2MultiWord((const unsigned int *)&r4.chunks[0U],
                           (unsigned int *)&r1.chunks[0U], 2);
    } else {
      r1 = r3;
    }
  } else {
    sMultiWord2MultiWord((const unsigned int *)&x.chunks[0U],
                         (unsigned int *)&r1.chunks[0U], 2);
  }
  if (uMultiWordEq((const unsigned int *)&r1.chunks[0U],
                   (const unsigned int *)&r5.chunks[0U])) {
    res = r5;
  } else {
    uint64m_T r6;
    std::frexp(1000.0, &xexp);
    xexp = -43;
    r6 = r7;
    uMultiWordDivZero(
        (const unsigned int *)&r1.chunks[0U],
        (const unsigned int *)&r7.chunks[0U], (unsigned int *)&res.chunks[0U],
        (unsigned int *)&nk_unsgn.chunks[0U], (unsigned int *)&r8.chunks[0U],
        (unsigned int *)&r9.chunks[0U]);
    uMultiWordDivZero(
        (const unsigned int *)&r1.chunks[0U],
        (const unsigned int *)&r7.chunks[0U],
        (unsigned int *)&nk_unsgn.chunks[0U], (unsigned int *)&r9.chunks[0U],
        (unsigned int *)&r11.chunks[0U], (unsigned int *)&r12.chunks[0U]);
    uMultiWordMul((const unsigned int *)&nk_unsgn.chunks[0U],
                  (const unsigned int *)&r7.chunks[0U],
                  (unsigned int *)&r15.chunks[0U]);
    uMultiWord2MultiWord((const unsigned int *)&r15.chunks[0U], 4,
                         (unsigned int *)&r6.chunks[0U]);
    MultiWordSub((const unsigned int *)&r1.chunks[0U],
                 (const unsigned int *)&r6.chunks[0U],
                 (unsigned int *)&nk_unsgn.chunks[0U], 2);
    int exitg1;
    do {
      exitg1 = 0;
      if (xexp < 0) {
        int shiftAmount;
        shiftAmount = -xexp;
        if (shiftAmount > 11) {
          shiftAmount = 11;
        }
        uMultiWordShr((const unsigned int *)&res.chunks[0U],
                      static_cast<unsigned int>(64 - shiftAmount),
                      (unsigned int *)&r9.chunks[0U]);
        if (uMultiWordGt((const unsigned int *)&r9.chunks[0U],
                         (const unsigned int *)&r5.chunks[0U])) {
          res = r18;
          exitg1 = 1;
        } else {
          uMultiWordShl((const unsigned int *)&res.chunks[0U],
                        static_cast<unsigned int>(shiftAmount),
                        (unsigned int *)&r17.chunks[0U]);
          uMultiWordShl((const unsigned int *)&nk_unsgn.chunks[0U],
                        static_cast<unsigned int>(shiftAmount),
                        (unsigned int *)&b_nk_unsgn.chunks[0U]);
          xexp += shiftAmount;
          r8 = r7;
          uMultiWordDivZero(
              (const unsigned int *)&b_nk_unsgn.chunks[0U],
              (const unsigned int *)&r7.chunks[0U],
              (unsigned int *)&t.chunks[0U], (unsigned int *)&res.chunks[0U],
              (unsigned int *)&r19.chunks[0U], (unsigned int *)&r20.chunks[0U]);
          res = r18;
          MultiWordSub((const unsigned int *)&r18.chunks[0U],
                       (const unsigned int *)&t.chunks[0U],
                       (unsigned int *)&r8.chunks[0U], 2);
          if (uMultiWordLe((const unsigned int *)&r8.chunks[0U],
                           (const unsigned int *)&r17.chunks[0U])) {
            exitg1 = 1;
          } else {
            MultiWordAdd((const unsigned int *)&r17.chunks[0U],
                         (const unsigned int *)&t.chunks[0U],
                         (unsigned int *)&res.chunks[0U]);
            uMultiWordDivZero((const unsigned int *)&b_nk_unsgn.chunks[0U],
                              (const unsigned int *)&r7.chunks[0U],
                              (unsigned int *)&r20.chunks[0U],
                              (unsigned int *)&r1.chunks[0U],
                              (unsigned int *)&r21.chunks[0U],
                              (unsigned int *)&r22.chunks[0U]);
            uMultiWordMul((const unsigned int *)&r20.chunks[0U],
                          (const unsigned int *)&r7.chunks[0U],
                          (unsigned int *)&r15.chunks[0U]);
            uMultiWord2MultiWord((const unsigned int *)&r15.chunks[0U], 4,
                                 (unsigned int *)&r19.chunks[0U]);
            MultiWordSub((const unsigned int *)&b_nk_unsgn.chunks[0U],
                         (const unsigned int *)&r19.chunks[0U],
                         (unsigned int *)&r20.chunks[0U], 2);
            nk_unsgn = r20;
          }
        }
      } else {
        uMultiWordShl((const unsigned int *)&nk_unsgn.chunks[0U], 1U,
                      (unsigned int *)&r6.chunks[0U]);
        if (uMultiWordGe((const unsigned int *)&r6.chunks[0U],
                         (const unsigned int *)&r7.chunks[0U])) {
          MultiWordAdd((const unsigned int *)&res.chunks[0U],
                       (const unsigned int *)&r16.chunks[0U],
                       (unsigned int *)&r11.chunks[0U]);
          res = r11;
        }
        exitg1 = 1;
      }
    } while (exitg1 == 0);
  }
  if (sMultiWordLt((const unsigned int *)&x.chunks[0U],
                   (const unsigned int *)&r.chunks[0U])) {
    if (uMultiWordLe((const unsigned int *)&res.chunks[0U],
                     (const unsigned int *)&r10.chunks[0U])) {
      uMultiWord2MultiWord((const unsigned int *)&res.chunks[0U], 2,
                           (unsigned int *)&r14.chunks[0U]);
      MultiWordNeg((const unsigned int *)&r14.chunks[0U],
                   (unsigned int *)&z.chunks[0U]);
    } else {
      z = r2;
    }
  } else if (uMultiWordLe((const unsigned int *)&res.chunks[0U],
                          (const unsigned int *)&r10.chunks[0U])) {
    uMultiWord2MultiWord((const unsigned int *)&res.chunks[0U], 2,
                         (unsigned int *)&z.chunks[0U]);
  } else {
    z = r13;
  }
  return z;
}

namespace lapack {
static int xgeqp3(array<double, 2U> &A, double tau_data[], int jpvt[2])
{
  int m_tmp;
  int tau_size;
  bool guard1;
  m_tmp = A.size(0);
  tau_size = A.size(0);
  if (tau_size > 2) {
    tau_size = 2;
  }
  if (tau_size - 1 >= 0) {
    std::memset(&tau_data[0], 0,
                static_cast<unsigned int>(tau_size) * sizeof(double));
  }
  guard1 = false;
  if (A.size(0) == 0) {
    guard1 = true;
  } else {
    int u0;
    u0 = A.size(0);
    if (u0 > 2) {
      u0 = 2;
    }
    if (u0 < 1) {
      guard1 = true;
    } else {
      double vn1[2];
      double vn2[2];
      double work[2];
      double temp;
      u0 = A.size(0);
      if (u0 > 2) {
        u0 = 2;
      }
      jpvt[0] = 1;
      work[0] = 0.0;
      temp = blas::xnrm2(m_tmp, A, 1);
      vn1[0] = temp;
      vn2[0] = temp;
      jpvt[1] = 2;
      work[1] = 0.0;
      temp = blas::xnrm2(m_tmp, A, m_tmp + 1);
      vn1[1] = temp;
      vn2[1] = temp;
      for (int i{0}; i < u0; i++) {
        double atmp;
        double temp2;
        int b_i;
        int ii;
        int ii_tmp;
        int ip1;
        int ix;
        int knt;
        int lastv;
        int mmi;
        int pvt;
        ip1 = i + 2;
        ii_tmp = i * m_tmp;
        ii = ii_tmp + i;
        mmi = m_tmp - i;
        ix = 0;
        if ((2 - i > 1) && (std::abs(vn1[1]) > std::abs(vn1[i]))) {
          ix = 1;
        }
        pvt = i + ix;
        if (pvt != i) {
          ix = pvt * m_tmp;
          for (lastv = 0; lastv < m_tmp; lastv++) {
            knt = ix + lastv;
            temp = A[knt];
            b_i = ii_tmp + lastv;
            A[knt] = A[b_i];
            A[b_i] = temp;
          }
          ix = jpvt[pvt];
          jpvt[pvt] = jpvt[i];
          jpvt[i] = ix;
          vn1[pvt] = vn1[i];
          vn2[pvt] = vn2[i];
        }
        if (i + 1 < m_tmp) {
          atmp = A[ii];
          ix = ii + 2;
          tau_data[i] = 0.0;
          if (mmi > 0) {
            temp = blas::xnrm2(mmi - 1, A, ii + 2);
            if (temp != 0.0) {
              temp2 = std::abs(A[ii]);
              temp = std::abs(temp);
              if (temp2 < temp) {
                temp2 /= temp;
                temp *= std::sqrt(temp2 * temp2 + 1.0);
              } else if (temp2 > temp) {
                temp /= temp2;
                temp = temp2 * std::sqrt(temp * temp + 1.0);
              } else if (std::isnan(temp)) {
                temp = rtNaN;
              } else {
                temp = temp2 * 1.4142135623730951;
              }
              if (A[ii] >= 0.0) {
                temp = -temp;
              }
              if (std::abs(temp) < 1.0020841800044864E-292) {
                knt = 0;
                b_i = ii + mmi;
                do {
                  knt++;
                  for (lastv = ix; lastv <= b_i; lastv++) {
                    A[lastv - 1] = 9.9792015476736E+291 * A[lastv - 1];
                  }
                  temp *= 9.9792015476736E+291;
                  atmp *= 9.9792015476736E+291;
                } while ((std::abs(temp) < 1.0020841800044864E-292) &&
                         (knt < 20));
                temp2 = std::abs(atmp);
                temp = std::abs(blas::xnrm2(mmi - 1, A, ii + 2));
                if (temp2 < temp) {
                  temp2 /= temp;
                  temp *= std::sqrt(temp2 * temp2 + 1.0);
                } else if (temp2 > temp) {
                  temp /= temp2;
                  temp = temp2 * std::sqrt(temp * temp + 1.0);
                } else if (std::isnan(temp)) {
                  temp = rtNaN;
                } else {
                  temp = temp2 * 1.4142135623730951;
                }
                if (atmp >= 0.0) {
                  temp = -temp;
                }
                tau_data[i] = (temp - atmp) / temp;
                temp2 = 1.0 / (atmp - temp);
                for (lastv = ix; lastv <= b_i; lastv++) {
                  A[lastv - 1] = temp2 * A[lastv - 1];
                }
                for (lastv = 0; lastv < knt; lastv++) {
                  temp *= 1.0020841800044864E-292;
                }
                atmp = temp;
              } else {
                tau_data[i] = (temp - A[ii]) / temp;
                temp2 = 1.0 / (A[ii] - temp);
                b_i = ii + mmi;
                for (lastv = ix; lastv <= b_i; lastv++) {
                  A[lastv - 1] = temp2 * A[lastv - 1];
                }
                atmp = temp;
              }
            }
          }
          A[ii] = atmp;
        } else {
          tau_data[i] = 0.0;
        }
        if (i + 1 < 2) {
          int jA;
          atmp = A[ii];
          A[ii] = 1.0;
          jA = (ii + m_tmp) + 1;
          if (tau_data[0] != 0.0) {
            lastv = mmi - 1;
            ix = (ii + mmi) - 1;
            while ((lastv + 1 > 0) && (A[ix] == 0.0)) {
              lastv--;
              ix--;
            }
            pvt = 1;
            ix = jA;
            int exitg1;
            do {
              exitg1 = 0;
              if (ix <= jA + lastv) {
                if (A[ix - 1] != 0.0) {
                  exitg1 = 1;
                } else {
                  ix++;
                }
              } else {
                pvt = 0;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          } else {
            lastv = -1;
            pvt = 0;
          }
          if (lastv + 1 > 0) {
            if (pvt != 0) {
              work[0] = 0.0;
              knt = 0;
              for (ii_tmp = jA; m_tmp < 0 ? ii_tmp >= jA : ii_tmp <= jA;
                   ii_tmp += m_tmp) {
                temp = 0.0;
                b_i = ii_tmp + lastv;
                for (ix = ii_tmp; ix <= b_i; ix++) {
                  temp += A[ix - 1] * A[(ii + ix) - ii_tmp];
                }
                work[knt] += temp;
                knt++;
              }
            }
            if (!(-tau_data[0] == 0.0)) {
              for (ii_tmp = 0; ii_tmp < pvt; ii_tmp++) {
                if (work[0] != 0.0) {
                  temp = work[0] * -tau_data[0];
                  b_i = lastv + jA;
                  for (knt = jA; knt <= b_i; knt++) {
                    A[knt - 1] = A[knt - 1] + A[(ii + knt) - jA] * temp;
                  }
                }
                jA += m_tmp;
              }
            }
          }
          A[ii] = atmp;
        }
        for (ii_tmp = ip1; ii_tmp < 3; ii_tmp++) {
          ix = i + m_tmp;
          if (vn1[1] != 0.0) {
            temp = std::abs(A[ix]) / vn1[1];
            temp = 1.0 - temp * temp;
            if (temp < 0.0) {
              temp = 0.0;
            }
            temp2 = vn1[1] / vn2[1];
            temp2 = temp * (temp2 * temp2);
            if (temp2 <= 1.4901161193847656E-8) {
              if (i + 1 < m_tmp) {
                temp = blas::xnrm2(mmi - 1, A, ix + 2);
                vn1[1] = temp;
                vn2[1] = temp;
              } else {
                vn1[1] = 0.0;
                vn2[1] = 0.0;
              }
            } else {
              vn1[1] *= std::sqrt(temp);
            }
          }
        }
      }
    }
  }
  if (guard1) {
    jpvt[0] = 1;
    jpvt[1] = 2;
  }
  return tau_size;
}

} // namespace lapack
static double maximum(const array<double, 2U> &x)
{
  double ex;
  int last;
  last = x.size(1);
  if (x.size(1) <= 2) {
    if (x.size(1) == 1) {
      ex = x[0];
    } else {
      ex = x[x.size(1) - 1];
      if ((!(x[0] < ex)) && ((!std::isnan(x[0])) || std::isnan(ex))) {
        ex = x[0];
      }
    }
  } else {
    int idx;
    int k;
    if (!std::isnan(x[0])) {
      idx = 1;
    } else {
      bool exitg1;
      idx = 0;
      k = 2;
      exitg1 = false;
      while ((!exitg1) && (k <= last)) {
        if (!std::isnan(x[k - 1])) {
          idx = k;
          exitg1 = true;
        } else {
          k++;
        }
      }
    }
    if (idx == 0) {
      ex = x[0];
    } else {
      ex = x[idx - 1];
      idx++;
      for (k = idx; k <= last; k++) {
        double d;
        d = x[k - 1];
        if (ex < d) {
          ex = d;
        }
      }
    }
  }
  return ex;
}

} // namespace internal
static void interp1(const array<double, 2U> &varargin_1,
                    const array<double, 2U> &varargin_2,
                    const array<double, 2U> &varargin_3, array<double, 2U> &Vq)
{
  array<double, 2U> b_y;
  array<double, 2U> pp_coefs;
  array<double, 2U> x;
  array<double, 2U> y;
  int i;
  int loop_ub;
  int nd2;
  int nx;
  loop_ub = varargin_2.size(1);
  y.set_size(1, varargin_2.size(1));
  for (i = 0; i < loop_ub; i++) {
    y[i] = varargin_2[i];
  }
  nd2 = varargin_1.size(1);
  x.set_size(1, varargin_1.size(1));
  for (i = 0; i < nd2; i++) {
    x[i] = varargin_1[i];
  }
  nx = varargin_1.size(1) - 1;
  Vq.set_size(1, varargin_3.size(1));
  nd2 = varargin_3.size(1);
  for (i = 0; i < nd2; i++) {
    Vq[i] = 0.0;
  }
  if (varargin_3.size(1) != 0) {
    double xtmp;
    if (varargin_1[1] < varargin_1[0]) {
      i = varargin_1.size(1) >> 1;
      for (int b_j1{0}; b_j1 < i; b_j1++) {
        xtmp = x[b_j1];
        nd2 = nx - b_j1;
        x[b_j1] = x[nd2];
        x[nd2] = xtmp;
      }
      nd2 = varargin_2.size(1) >> 1;
      for (int b_j1{0}; b_j1 < nd2; b_j1++) {
        nx = (varargin_2.size(1) - b_j1) - 1;
        xtmp = y[b_j1];
        y[b_j1] = y[nx];
        y[nx] = xtmp;
      }
    }
    b_y.set_size(1, varargin_2.size(1));
    for (i = 0; i < loop_ub; i++) {
      b_y[i] = y[i];
    }
    pchip(x, b_y, y, pp_coefs);
    nd2 = varargin_3.size(1);
    for (nx = 0; nx < nd2; nx++) {
      xtmp = varargin_3[nx];
      if (std::isnan(xtmp)) {
        Vq[nx] = rtNaN;
      } else {
        Vq[nx] = ppval(y, pp_coefs, xtmp);
      }
    }
  }
}

static void interp1(const array<double, 2U> &varargin_1,
                    const array<double, 2U> &varargin_2,
                    const double varargin_3[100], double Vq[100])
{
  array<double, 2U> b_y;
  array<double, 2U> pp_coefs;
  array<double, 2U> x;
  array<double, 2U> y;
  double xtmp;
  int i;
  int loop_ub;
  int nx;
  loop_ub = varargin_2.size(1);
  y.set_size(1, varargin_2.size(1));
  for (i = 0; i < loop_ub; i++) {
    y[i] = varargin_2[i];
  }
  nx = varargin_1.size(1);
  x.set_size(1, varargin_1.size(1));
  for (i = 0; i < nx; i++) {
    x[i] = varargin_1[i];
  }
  nx = varargin_1.size(1) - 1;
  if (varargin_1[1] < varargin_1[0]) {
    int j2;
    i = varargin_1.size(1) >> 1;
    for (int b_j1{0}; b_j1 < i; b_j1++) {
      xtmp = x[b_j1];
      j2 = nx - b_j1;
      x[b_j1] = x[j2];
      x[j2] = xtmp;
    }
    nx = varargin_2.size(1) >> 1;
    for (int b_j1{0}; b_j1 < nx; b_j1++) {
      j2 = (varargin_2.size(1) - b_j1) - 1;
      xtmp = y[b_j1];
      y[b_j1] = y[j2];
      y[j2] = xtmp;
    }
  }
  b_y.set_size(1, varargin_2.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_y[i] = y[i];
  }
  pchip(x, b_y, y, pp_coefs);
  for (nx = 0; nx < 100; nx++) {
    xtmp = varargin_3[nx];
    if (std::isnan(xtmp)) {
      Vq[nx] = rtNaN;
    } else {
      Vq[nx] = ppval(y, pp_coefs, xtmp);
    }
  }
}

static void linspace(double d2, double y[100])
{
  double delta1;
  y[99] = d2;
  y[0] = 1.0;
  delta1 = (d2 - 1.0) / 99.0;
  for (int k{0}; k < 98; k++) {
    y[k + 1] = (static_cast<double>(k) + 1.0) * delta1 + 1.0;
  }
}

static void linspace(double d1, double d2, const int64m_T n,
                     array<double, 2U> &y)
{
  static const int64m_T r{
      {0U, 0U} // chunks
  };
  if (sMultiWordLt((const unsigned int *)&n.chunks[0U],
                   (const unsigned int *)&r.chunks[0U])) {
    y.set_size(1, 0);
  } else {
    int i;
    i = MultiWord2sLong((const unsigned int *)&n.chunks[0U]);
    y.set_size(1, i);
    if (i >= 1) {
      y[MultiWord2sLong((const unsigned int *)&n.chunks[0U]) - 1] = d2;
      if (y.size(1) >= 2) {
        y[0] = d1;
        if (y.size(1) >= 3) {
          if (d1 == -d2) {
            double delta1;
            delta1 = d2 / (static_cast<double>(y.size(1)) - 1.0);
            for (int k{2}; k < i; k++) {
              y[k - 1] =
                  static_cast<double>(((k << 1) - y.size(1)) - 1) * delta1;
            }
            if ((static_cast<unsigned int>(y.size(1)) & 1U) == 1U) {
              y[y.size(1) >> 1] = 0.0;
            }
          } else {
            double delta1;
            delta1 = (d2 - d1) / (static_cast<double>(y.size(1)) - 1.0);
            for (int k{0}; k <= i - 3; k++) {
              y[k + 1] = d1 + (static_cast<double>(k) + 1.0) * delta1;
            }
          }
        }
      }
    }
  }
}

static void pchip(const array<double, 2U> &x, const array<double, 2U> &y,
                  array<double, 2U> &v_breaks, array<double, 2U> &v_coefs)
{
  array<double, 2U> del;
  array<double, 2U> h;
  array<double, 2U> slopes;
  double d;
  double d2;
  double dzdxdx;
  double dzzdx;
  double signd1;
  int i;
  int nxm2;
  nxm2 = x.size(1) - 2;
  h.set_size(1, x.size(1) - 1);
  i = y.size(1) - 1;
  del.set_size(1, y.size(1) - 1);
  for (int k{0}; k <= nxm2; k++) {
    d2 = x[k + 1] - x[k];
    h[k] = d2;
    del[k] = (y[k + 1] - y[k]) / d2;
  }
  slopes.set_size(1, y.size(1));
  if (x.size(1) == 2) {
    slopes[0] = del[0];
    slopes[1] = del[0];
  } else {
    nxm2 = x.size(1);
    for (int k{0}; k <= nxm2 - 3; k++) {
      d2 = h[k + 1];
      d = h[k];
      signd1 = 2.0 * d2 + d;
      dzdxdx = d2 + 2.0 * d;
      slopes[k + 1] = 0.0;
      d2 = del[k];
      d = del[k + 1];
      dzzdx = d2 * d;
      if (!std::isnan(dzzdx)) {
        if (dzzdx < 0.0) {
          dzzdx = -1.0;
        } else {
          dzzdx = (dzzdx > 0.0);
        }
      }
      if (dzzdx > 0.0) {
        slopes[k + 1] = (signd1 + dzdxdx) / (signd1 / d2 + dzdxdx / d);
      }
    }
    dzzdx = del[0];
    d2 = del[1];
    dzdxdx = h[0];
    signd1 = h[1];
    dzdxdx =
        ((2.0 * dzdxdx + signd1) * dzzdx - dzdxdx * d2) / (dzdxdx + signd1);
    if (std::isnan(dzzdx)) {
      signd1 = rtNaN;
    } else if (dzzdx < 0.0) {
      signd1 = -1.0;
    } else {
      signd1 = (dzzdx > 0.0);
    }
    if (std::isnan(dzdxdx)) {
      d = rtNaN;
    } else if (dzdxdx < 0.0) {
      d = -1.0;
    } else {
      d = (dzdxdx > 0.0);
    }
    if (d != signd1) {
      dzdxdx = 0.0;
    } else {
      if (std::isnan(d2)) {
        d = rtNaN;
      } else if (d2 < 0.0) {
        d = -1.0;
      } else {
        d = (d2 > 0.0);
      }
      if ((signd1 != d) && (std::abs(dzdxdx) > std::abs(3.0 * dzzdx))) {
        dzdxdx = 3.0 * dzzdx;
      }
    }
    slopes[0] = dzdxdx;
    dzzdx = del[x.size(1) - 2];
    d2 = del[x.size(1) - 3];
    dzdxdx = h[x.size(1) - 2];
    signd1 = h[x.size(1) - 3];
    dzdxdx =
        ((2.0 * dzdxdx + signd1) * dzzdx - dzdxdx * d2) / (dzdxdx + signd1);
    if (std::isnan(dzzdx)) {
      signd1 = rtNaN;
    } else if (dzzdx < 0.0) {
      signd1 = -1.0;
    } else {
      signd1 = (dzzdx > 0.0);
    }
    if (std::isnan(dzdxdx)) {
      d = rtNaN;
    } else if (dzdxdx < 0.0) {
      d = -1.0;
    } else {
      d = (dzdxdx > 0.0);
    }
    if (d != signd1) {
      dzdxdx = 0.0;
    } else {
      if (std::isnan(d2)) {
        d = rtNaN;
      } else if (d2 < 0.0) {
        d = -1.0;
      } else {
        d = (d2 > 0.0);
      }
      if ((signd1 != d) && (std::abs(dzdxdx) > std::abs(3.0 * dzzdx))) {
        dzdxdx = 3.0 * dzzdx;
      }
    }
    slopes[x.size(1) - 1] = dzdxdx;
  }
  nxm2 = x.size(1);
  v_breaks.set_size(1, x.size(1));
  for (int k{0}; k < nxm2; k++) {
    v_breaks[k] = x[k];
  }
  v_coefs.set_size(y.size(1) - 1, 4);
  for (int k{0}; k <= nxm2 - 2; k++) {
    d2 = del[k];
    d = slopes[k];
    signd1 = h[k];
    dzzdx = (d2 - d) / signd1;
    dzdxdx = (slopes[k + 1] - d2) / signd1;
    v_coefs[k] = (dzdxdx - dzzdx) / signd1;
    v_coefs[i + k] = 2.0 * dzzdx - dzdxdx;
    v_coefs[(i << 1) + k] = d;
    v_coefs[3 * i + k] = y[k];
  }
}

static double ppval(const array<double, 2U> &pp_breaks,
                    const array<double, 2U> &pp_coefs, double x)
{
  double v;
  if (std::isnan(x)) {
    v = rtNaN;
  } else {
    int high_i;
    int low_i;
    int low_ip1;
    high_i = pp_breaks.size(1);
    low_i = 1;
    low_ip1 = 2;
    while (high_i > low_ip1) {
      int mid_i;
      mid_i = (low_i >> 1) + (high_i >> 1);
      if (((static_cast<unsigned int>(low_i) & 1U) == 1U) &&
          ((static_cast<unsigned int>(high_i) & 1U) == 1U)) {
        mid_i++;
      }
      if (x >= pp_breaks[mid_i - 1]) {
        low_i = mid_i;
        low_ip1 = mid_i + 1;
      } else {
        high_i = mid_i;
      }
    }
    v = x - pp_breaks[low_i - 1];
    v = v * (v * (v * pp_coefs[low_i - 1] +
                  pp_coefs[(low_i + pp_breaks.size(1)) - 2]) +
             pp_coefs[(low_i + ((pp_breaks.size(1) - 1) << 1)) - 1]) +
        pp_coefs[(low_i + 3 * (pp_breaks.size(1) - 1)) - 1];
  }
  return v;
}

} // namespace coder
static void minus(coder::array<double, 1U> &in1,
                  const coder::array<double, 1U> &in2)
{
  coder::array<double, 1U> b_in1;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in2.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in2.size(0);
  }
  b_in1.set_size(loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_1_0 = (in2.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in1[i] = in1[i * stride_0_0] - in2[i * stride_1_0];
  }
  in1.set_size(loop_ub);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in1[i];
  }
}

static double sMultiWord2Double(const unsigned int u1[])
{
  double y;
  int b_exp;
  y = 0.0;
  b_exp = 0;
  if ((u1[1] & 2147483648U) != 0U) {
    int cb;
    cb = 1;
    for (int i{0}; i < 2; i++) {
      unsigned int u1i;
      unsigned int yi;
      u1i = ~u1[i];
      yi = u1i + static_cast<unsigned int>(cb);
      y -= std::ldexp(static_cast<double>(yi), b_exp);
      cb = (yi < u1i);
      b_exp += 32;
    }
  } else {
    for (int i{0}; i < 2; i++) {
      y += std::ldexp(static_cast<double>(u1[i]), b_exp);
      b_exp += 32;
    }
  }
  return y;
}

static void sMultiWord2MultiWord(const unsigned int u1[], unsigned int y[],
                                 int n)
{
  int nm;
  if (n >= 2) {
    nm = 2;
  } else {
    nm = n;
  }
  if (nm - 1 >= 0) {
    std::copy(&u1[0], &u1[nm], &y[0]);
  }
  if (n > 2) {
    unsigned int u1i;
    if ((u1[1] & 2147483648U) != 0U) {
      u1i = MAX_uint32_T;
    } else {
      u1i = 0U;
    }
    for (int i{nm}; i < n; i++) {
      y[i] = u1i;
    }
  }
}

static void sMultiWord2sMultiWordSat(const unsigned int u1[], unsigned int y[])
{
  int i;
  unsigned int ys;
  bool doSaturation{false};
  if ((u1[2] & 2147483648U) != 0U) {
    ys = MAX_uint32_T;
  } else {
    ys = 0U;
  }
  doSaturation = (((u1[1] ^ u1[2]) & 2147483648U) != 0U);
  i = 2;
  while ((!doSaturation) && (i >= 2)) {
    doSaturation = (u1[2] != ys);
    i = 1;
  }
  if (doSaturation) {
    ys = ~ys;
    y[0] = ys;
    y[1] = ys ^ 2147483648U;
  } else {
    for (i = 0; i < 2; i++) {
      y[i] = u1[i];
    }
    while (i < 2) {
      y[i] = ys;
      i++;
    }
  }
}

static int sMultiWordCmp(const unsigned int u1[], const unsigned int u2[])
{
  unsigned int su1;
  int y;
  su1 = u1[1] & 2147483648U;
  if (su1 != (u2[1] & 2147483648U)) {
    if (su1 != 0U) {
      y = -1;
    } else {
      y = 1;
    }
  } else {
    int i;
    y = 0;
    i = 2;
    while ((y == 0) && (i > 0)) {
      unsigned int u2i;
      i--;
      su1 = u1[i];
      u2i = u2[i];
      if (su1 != u2i) {
        if (su1 > u2i) {
          y = 1;
        } else {
          y = -1;
        }
      }
    }
  }
  return y;
}

static bool sMultiWordGt(const unsigned int u1[], const unsigned int u2[])
{
  return sMultiWordCmp(u1, u2) > 0;
}

static bool sMultiWordLt(const unsigned int u1[], const unsigned int u2[])
{
  return sMultiWordCmp(u1, u2) < 0;
}

static void sMultiWordMul(const unsigned int u1[], const unsigned int u2[],
                          unsigned int y[])
{
  unsigned int cb;
  int cb1;
  int k;
  unsigned int yk;
  bool isNegative1;
  bool isNegative2;
  isNegative1 = ((u1[1] & 2147483648U) != 0U);
  isNegative2 = ((u2[1] & 2147483648U) != 0U);
  cb1 = 1;
  // Initialize output to zero
  for (k = 0; k < 3; k++) {
    y[k] = 0U;
  }
  for (int i{0}; i < 2; i++) {
    int a0;
    int a1;
    int cb2;
    unsigned int u1i;
    cb = 0U;
    u1i = u1[i];
    if (isNegative1) {
      u1i = ~u1i + static_cast<unsigned int>(cb1);
      cb1 = (u1i < static_cast<unsigned int>(cb1));
    }
    a1 = static_cast<int>(u1i >> 16U);
    a0 = static_cast<int>(u1i & 65535U);
    cb2 = 1;
    k = i;
    for (int j{0}; j < 2; j++) {
      int b0;
      int b1;
      unsigned int t;
      unsigned int w01;
      u1i = u2[j];
      if (isNegative2) {
        u1i = ~u1i + static_cast<unsigned int>(cb2);
        cb2 = (u1i < static_cast<unsigned int>(cb2));
      }
      b1 = static_cast<int>(u1i >> 16U);
      b0 = static_cast<int>(u1i & 65535U);
      u1i = static_cast<unsigned int>(a1) * static_cast<unsigned int>(b0);
      w01 = static_cast<unsigned int>(a0) * static_cast<unsigned int>(b1);
      yk = y[k] + cb;
      cb = (yk < cb);
      t = static_cast<unsigned int>(a0) * static_cast<unsigned int>(b0);
      yk += t;
      cb += (yk < t);
      t = u1i << 16U;
      yk += t;
      cb += (yk < t);
      t = w01 << 16U;
      yk += t;
      cb += (yk < t);
      y[k] = yk;
      cb += u1i >> 16U;
      cb += w01 >> 16U;
      cb += static_cast<unsigned int>(a1) * static_cast<unsigned int>(b1);
      k++;
    }
    if (k < 3) {
      y[k] = cb;
    }
  }
  // Apply sign
  if (isNegative1 != isNegative2) {
    cb = 1U;
    for (k = 0; k < 3; k++) {
      yk = ~y[k] + cb;
      y[k] = yk;
      cb = (yk < cb);
    }
  }
}

static void uMultiWord2MultiWord(const unsigned int u1[], int n1,
                                 unsigned int y[])
{
  int nm;
  if (n1 <= 2) {
    nm = n1;
  } else {
    nm = 2;
  }
  if (nm - 1 >= 0) {
    std::copy(&u1[0], &u1[nm], &y[0]);
  }
  if (n1 < 2) {
    for (int i{nm}; i < 2; i++) {
      y[i] = 0U;
    }
  }
}

static int uMultiWordCmp(const unsigned int u1[], const unsigned int u2[])
{
  int i;
  int y;
  y = 0;
  i = 2;
  while ((y == 0) && (i > 0)) {
    unsigned int u1i;
    unsigned int u2i;
    i--;
    u1i = u1[i];
    u2i = u2[i];
    if (u1i != u2i) {
      if (u1i > u2i) {
        y = 1;
      } else {
        y = -1;
      }
    }
  }
  return y;
}

static int uMultiWordDiv(unsigned int a[], unsigned int b[], unsigned int q[],
                         unsigned int r[])
{
  int nzb;
  int tpi;
  int y;
  nzb = 2;
  tpi = 1;
  while ((nzb > 0) && (b[tpi] == 0U)) {
    nzb--;
    tpi--;
  }
  if (nzb > 0) {
    int nza;
    nza = 2;
    for (tpi = 0; tpi < 2; tpi++) {
      q[tpi] = 0U;
    }
    tpi = 1;
    while ((nza > 0) && (a[tpi] == 0U)) {
      nza--;
      tpi--;
    }
    if ((nza > 0) && (nza >= nzb)) {
      int kr;
      int na1;
      int nb1;
      nb1 = nzb - 1;
      na1 = nza - 1;
      for (kr = 0; kr < 2; kr++) {
        r[kr] = 0U;
      }
      // Quick return if dividend and divisor fit into single word.
      if (nza == 1) {
        unsigned int ak;
        unsigned int bk;
        unsigned int u;
        ak = a[0];
        bk = b[0];
        u = ak / bk;
        q[0] = u;
        r[0] = ak - u * bk;
        y = 7;
      } else {
        unsigned int kba;
        unsigned int kbb;
        unsigned int t;
        // Remove leading zeros from both, dividend and divisor.
        kbb = 1U;
        t = b[nzb - 1] >> 1U;
        while (t != 0U) {
          kbb++;
          t >>= 1U;
        }
        kba = 1U;
        t = a[1] >> 1U;
        while (t != 0U) {
          kba++;
          t >>= 1U;
        }
        // Quick return if quotient is zero.
        if ((nzb < 2) || (kba >= kbb)) {
          unsigned int ak;
          unsigned int bk;
          int ka;
          unsigned int mask;
          unsigned int nba;
          unsigned int nbb;
          unsigned int tnb;
          unsigned int u;
          nba = kba + 32U;
          nbb = static_cast<unsigned int>(nzb - 1) * 32U + kbb;
          // Normalize b.
          if (kbb != 32U) {
            bk = b[nzb - 1];
            kr = nzb - 1;
            while (kr > 0) {
              t = bk << (32U - kbb);
              bk = b[0];
              t |= bk >> kbb;
              b[1] = t;
              kr = 0;
            }
            b[0] = bk << (32U - kbb);
            mask = ~((1U << (32U - kbb)) - 1U);
          } else {
            mask = MAX_uint32_T;
          }
          // Initialize quotient to zero.
          tnb = 0U;
          y = 0;
          // Until exit conditions have been met, do
          do {
            // Normalize a
            if (kba != 32U) {
              tnb = (tnb - kba) + 32U;
              ak = a[na1];
              ka = na1;
              while (ka > 0) {
                t = ak << (32U - kba);
                ak = a[0];
                t |= ak >> kba;
                a[1] = t;
                ka = 0;
              }
              a[0] = ak << (32U - kba);
            }
            // Compare b against the a.
            ak = a[na1];
            bk = b[nzb - 1];
            if (nzb - 1 == 0) {
              u = mask;
            } else {
              u = MAX_uint32_T;
            }
            if ((ak & u) == bk) {
              tpi = 0;
              ka = na1;
              kr = nzb - 1;
              while ((tpi == 0) && (kr > 0)) {
                ka--;
                ak = a[ka];
                kr = 0;
                bk = b[0];
                if ((ak & mask) != bk) {
                  if (ak > bk) {
                    tpi = 1;
                  } else {
                    tpi = -1;
                  }
                }
              }
            } else if (ak > bk) {
              tpi = 1;
            } else {
              tpi = -1;
            }
            // If the remainder in a is still greater or equal to b, subtract
            // normalized divisor from a.
            if ((tpi >= 0) || (nba > nbb)) {
              u = nba - nbb;
              // If the remainder and the divisor are equal, set remainder to
              // zero.
              if (tpi == 0) {
                ka = na1;
                kr = nzb - 1;
                while (kr > 0) {
                  a[ka] = 0U;
                  ka--;
                  kr = 0;
                }
                a[ka] -= b[0];
              } else {
                // Otherwise, subtract the divisor from the remainder
                if (tpi < 0) {
                  ak = a[na1];
                  kba = 31U;
                  ka = na1;
                  while (ka > 0) {
                    t = ak << 1U;
                    ak = a[0];
                    t |= ak >> 31U;
                    a[1] = t;
                    ka = 0;
                  }
                  a[0] = ak << 1U;
                  tnb++;
                  u--;
                }
                tpi = 0;
                ka = (na1 - nzb) + 1;
                for (kr = 0; kr < nzb; kr++) {
                  t = a[ka];
                  ak = (t - b[kr]) - static_cast<unsigned int>(tpi);
                  if (tpi != 0) {
                    tpi = (ak >= t);
                  } else {
                    tpi = (ak > t);
                  }
                  a[ka] = ak;
                  ka++;
                }
              }
              // Update the quotient.
              tpi = static_cast<int>(u) / 32;
              q[tpi] |= 1U << (u - static_cast<unsigned int>(tpi) * 32U);
              // Remove leading zeros from the remainder and check whether the
              // exit conditions have been met.
              tpi = na1;
              while ((nza > 0) && (a[tpi] == 0U)) {
                nza--;
                tpi--;
              }
              if (nza >= nzb) {
                na1 = nza - 1;
                kba = 1U;
                t = a[nza - 1] >> 1U;
                while (t != 0U) {
                  kba++;
                  t >>= 1U;
                }
                nba = (static_cast<unsigned int>(nza - 1) * 32U + kba) - tnb;
                if (nba < nbb) {
                  y = 2;
                }
              } else if (nza == 0) {
                y = 1;
              } else {
                na1 = 0;
                y = 4;
              }
            } else {
              y = 3;
            }
          } while (y == 0);
          // Return the remainder.
          if (y == 1) {
            r[0] = a[0];
          } else {
            tpi = static_cast<int>(tnb) / 32;
            u = tnb - static_cast<unsigned int>(tpi) * 32U;
            if (u == 0U) {
              ka = tpi;
              for (kr = 0; kr <= nb1; kr++) {
                r[kr] = a[ka];
                ka++;
              }
            } else {
              ak = a[tpi];
              kr = 0;
              for (ka = tpi + 1; ka <= na1; ka++) {
                t = ak >> u;
                ak = a[ka];
                t |= ak << (32U - u);
                r[kr] = t;
                kr++;
              }
              r[kr] = ak >> u;
            }
          }
          // Restore b.
          if (kbb != 32U) {
            bk = b[0];
            for (kr = 0; kr < nb1; kr++) {
              t = bk >> (32U - kbb);
              bk = b[1];
              t |= bk << kbb;
              b[0] = t;
            }
            b[kr] = bk >> (32U - kbb);
          }
        } else {
          for (kr = 0; kr < 2; kr++) {
            r[kr] = a[kr];
          }
          y = 6;
        }
      }
    } else {
      for (int kr{0}; kr < 2; kr++) {
        r[kr] = a[kr];
      }
      y = 5;
    }
  } else {
    y = -1;
  }
  return y;
}

static void uMultiWordDivZero(const unsigned int u1[], const unsigned int u2[],
                              unsigned int b_y1[], unsigned int y2[],
                              unsigned int t1[], unsigned int t2[])
{
  uMultiWord2MultiWord(u1, 2, t1);
  uMultiWord2MultiWord(u2, 2, t2);
  if (uMultiWordDiv(t1, t2, b_y1, y2) < 0) {
    MultiWordSetUnsignedMax(b_y1);
  }
}

static bool uMultiWordEq(const unsigned int u1[], const unsigned int u2[])
{
  return uMultiWordCmp(u1, u2) == 0;
}

static bool uMultiWordGe(const unsigned int u1[], const unsigned int u2[])
{
  return uMultiWordCmp(u1, u2) >= 0;
}

static bool uMultiWordGt(const unsigned int u1[], const unsigned int u2[])
{
  return uMultiWordCmp(u1, u2) > 0;
}

static bool uMultiWordLe(const unsigned int u1[], const unsigned int u2[])
{
  return uMultiWordCmp(u1, u2) <= 0;
}

static void uMultiWordMul(const unsigned int u1[], const unsigned int u2[],
                          unsigned int y[])
{
  int k;
  // Initialize output to zero
  for (k = 0; k < 4; k++) {
    y[k] = 0U;
  }
  for (int i{0}; i < 2; i++) {
    int a0;
    int a1;
    unsigned int cb;
    unsigned int u1i;
    cb = 0U;
    u1i = u1[i];
    a1 = static_cast<int>(u1i >> 16U);
    a0 = static_cast<int>(u1i & 65535U);
    k = i;
    for (int j{0}; j < 2; j++) {
      int b0;
      int b1;
      unsigned int t;
      unsigned int w01;
      unsigned int yk;
      u1i = u2[j];
      b1 = static_cast<int>(u1i >> 16U);
      b0 = static_cast<int>(u1i & 65535U);
      u1i = static_cast<unsigned int>(a1) * static_cast<unsigned int>(b0);
      w01 = static_cast<unsigned int>(a0) * static_cast<unsigned int>(b1);
      yk = y[k] + cb;
      cb = (yk < cb);
      t = static_cast<unsigned int>(a0) * static_cast<unsigned int>(b0);
      yk += t;
      cb += (yk < t);
      t = u1i << 16U;
      yk += t;
      cb += (yk < t);
      t = w01 << 16U;
      yk += t;
      cb += (yk < t);
      y[k] = yk;
      cb += u1i >> 16U;
      cb += w01 >> 16U;
      cb += static_cast<unsigned int>(a1) * static_cast<unsigned int>(b1);
      k++;
    }
    if (k < 4) {
      y[k] = cb;
    }
  }
}

static void uMultiWordShl(const unsigned int u1[], unsigned int n2,
                          unsigned int y[])
{
  int i;
  int nb;
  int nc;
  unsigned int u1i;
  unsigned int ys;
  nb = static_cast<int>(n2) / 32;
  if ((u1[1] & 2147483648U) != 0U) {
    ys = MAX_uint32_T;
  } else {
    ys = 0U;
  }
  if (nb > 2) {
    nc = 2;
  } else {
    nc = nb;
  }
  u1i = 0U;
  if (nc - 1 >= 0) {
    std::memset(&y[0], 0, static_cast<unsigned int>(nc) * sizeof(unsigned int));
  }
  for (i = 0; i < nc; i++) {
  }
  if (nb < 2) {
    unsigned int nl;
    nl = n2 - static_cast<unsigned int>(nb) * 32U;
    nc = nb + 2;
    if (nb + 2 > 2) {
      nc = 2;
    }
    nc -= i;
    if (nl > 0U) {
      for (nb = 0; nb < nc; nb++) {
        unsigned int yi;
        yi = u1i >> (32U - nl);
        u1i = u1[nb];
        y[i] = yi | u1i << nl;
        i++;
      }
      if (i < 2) {
        y[i] = u1i >> (32U - nl) | ys << nl;
        i++;
      }
    } else {
      for (nb = 0; nb < nc; nb++) {
        y[i] = u1[nb];
        i++;
      }
    }
  }
  while (i < 2) {
    y[i] = ys;
    i++;
  }
}

static void uMultiWordShr(const unsigned int u1[], unsigned int n2,
                          unsigned int y[])
{
  int i;
  int nb;
  nb = static_cast<int>(n2) / 32;
  i = 0;
  if (nb < 2) {
    int nc;
    unsigned int nr;
    nc = nb + 2;
    if (nb + 2 > 2) {
      nc = 2;
    }
    nr = n2 - static_cast<unsigned int>(nb) * 32U;
    if (nr > 0U) {
      unsigned int u1i;
      unsigned int yi;
      u1i = u1[nb];
      for (int i1{nb + 1}; i1 < nc; i1++) {
        yi = u1i >> nr;
        u1i = u1[i1];
        y[i] = yi | u1i << (32U - nr);
        i++;
      }
      yi = u1i >> nr;
      if (nc < 2) {
        yi |= u1[nc] << (32U - nr);
      }
      y[i] = yi;
      i++;
    } else {
      for (int i1{nb}; i1 < nc; i1++) {
        y[i] = u1[i1];
        i++;
      }
    }
  }
  while (i < 2) {
    y[i] = 0U;
    i++;
  }
}

void preprocess_ppg_signal(const coder::array<double, 2U> &ppg_signal,
                           const coder::array<int64m_T, 2U> &timestamps,
                           coder::array<double, 2U> &processed_ppg_signal)
{
  static const int64m_T r2{
      {150U, 0U} // chunks
  };
  coder::array<double, 2U> b_processed_ppg_signal;
  coder::array<double, 2U> b_timestamps;
  coder::array<double, 2U> r;
  int96m_T r3;
  int96m_T r5;
  int96m_T r6;
  int96m_T r7;
  double y;
  int loop_ub;
  // PREPROCESS_PPG_SIGNAL Returns a processed copy of a raw PPG signal (red
  // channel values of a camera recording at the given timestamps,
  // in milliseconds). Assumes raw PPG signal has the correct orientation.
  //  Normalize and rescale to [0, 1] range
  y = coder::combineVectorElements(ppg_signal) /
      static_cast<double>(ppg_signal.size(1));
  loop_ub = ppg_signal.size(1);
  processed_ppg_signal.set_size(1, ppg_signal.size(1));
  for (int i{0}; i < loop_ub; i++) {
    processed_ppg_signal[i] = ppg_signal[i] - y;
  }
  coder::b_abs(processed_ppg_signal, r);
  y = coder::internal::maximum(r);
  processed_ppg_signal.set_size(1, processed_ppg_signal.size(1));
  loop_ub = processed_ppg_signal.size(1) - 1;
  for (int i{0}; i <= loop_ub; i++) {
    processed_ppg_signal[i] = processed_ppg_signal[i] / y;
  }
  //  Interpolate using cubic interpolation
  //  Hz
  //  Milliseconds -> Seconds
  loop_ub = timestamps.size(1);
  b_timestamps.set_size(1, timestamps.size(1));
  for (int i{0}; i < loop_ub; i++) {
    b_timestamps[i] =
        sMultiWord2Double((const unsigned int *)&timestamps[i].chunks[0U]);
  }
  int64m_T r1;
  int64m_T r4;
  r1 = r2;
  sMultiWord2MultiWord(
      (const unsigned int *)&timestamps[timestamps.size(1) - 1].chunks[0U],
      (unsigned int *)&r3.chunks[0U], 3);
  r4 = timestamps[0];
  sMultiWord2MultiWord((const unsigned int *)&timestamps[0].chunks[0U],
                       (unsigned int *)&r5.chunks[0U], 3);
  MultiWordSub((const unsigned int *)&r3.chunks[0U],
               (const unsigned int *)&r5.chunks[0U],
               (unsigned int *)&r6.chunks[0U], 3);
  sMultiWord2sMultiWordSat((const unsigned int *)&r6.chunks[0U],
                           (unsigned int *)&r4.chunks[0U]);
  r4 = coder::internal::i64ddiv(r4);
  sMultiWordMul((const unsigned int *)&r2.chunks[0U],
                (const unsigned int *)&r4.chunks[0U],
                (unsigned int *)&r7.chunks[0U]);
  sMultiWord2sMultiWordSat((const unsigned int *)&r7.chunks[0U],
                           (unsigned int *)&r1.chunks[0U]);
  coder::linspace(
      sMultiWord2Double((const unsigned int *)&timestamps[0].chunks[0U]),
      sMultiWord2Double(
          (const unsigned int *)&timestamps[timestamps.size(1) - 1].chunks[0U]),
      r1, r);
  b_processed_ppg_signal.set_size(1, processed_ppg_signal.size(1));
  loop_ub = processed_ppg_signal.size(0) * processed_ppg_signal.size(1) - 1;
  for (int i{0}; i <= loop_ub; i++) {
    b_processed_ppg_signal[i] = processed_ppg_signal[i];
  }
  coder::interp1(b_timestamps, b_processed_ppg_signal, r, processed_ppg_signal);
  //  Detrend
  b_processed_ppg_signal.set_size(1, processed_ppg_signal.size(1));
  loop_ub = processed_ppg_signal.size(0) * processed_ppg_signal.size(1) - 1;
  for (int i{0}; i <= loop_ub; i++) {
    b_processed_ppg_signal[i] = processed_ppg_signal[i];
  }
  coder::detrend(b_processed_ppg_signal, processed_ppg_signal);
}

void preprocess_ppg_signal_initialize()
{
}

void preprocess_ppg_signal_terminate()
{
}

void score_ppg_signal(const coder::array<double, 2U> &processed_ppg_signal,
                      const int64m_T coefficient_count,
                      coder::array<double, 1U> &scores)
{
  static const creal_T wwc[99]{{
                                   0.99802672842827156, // re
                                   0.062790519529313374 // im
                               },
                               {
                                   0.96858316112863108, // re
                                   0.24868988716485479  // im
                               },
                               {
                                   0.84432792550201508, // re
                                   0.53582679497899666  // im
                               },
                               {
                                   0.53582679497899655, // re
                                   0.84432792550201508  // im
                               },
                               {
                                   6.123233995736766E-17, // re
                                   1.0                    // im
                               },
                               {
                                   -0.63742398974868975, // re
                                   0.77051324277578925   // im
                               },
                               {
                                   -0.99802672842827156, // re
                                   0.062790519529313582  // im
                               },
                               {
                                   -0.63742398974868952, // re
                                   -0.77051324277578936  // im
                               },
                               {
                                   0.36812455268467742, // re
                                   -0.92977648588825157 // im
                               },
                               {
                                   1.0, // re
                                   0.0  // im
                               },
                               {
                                   0.24868988716485474, // re
                                   0.96858316112863108  // im
                               },
                               {
                                   -0.92977648588825135, // re
                                   0.36812455268467814   // im
                               },
                               {
                                   -0.36812455268467781, // re
                                   -0.92977648588825146  // im
                               },
                               {
                                   0.968583161128631,   // re
                                   -0.24868988716485535 // im
                               },
                               {
                                   6.123233995736766E-17, // re
                                   1.0                    // im
                               },
                               {
                                   -0.92977648588825146, // re
                                   -0.36812455268467792  // im
                               },
                               {
                                   0.77051324277578936, // re
                                   -0.63742398974868963 // im
                               },
                               {
                                   0.062790519529313527, // re
                                   0.99802672842827156   // im
                               },
                               {
                                   -0.77051324277578925, // re
                                   -0.63742398974868963  // im
                               },
                               {
                                   1.0, // re
                                   0.0  // im
                               },
                               {
                                   -0.84432792550201485, // re
                                   0.535826794978997     // im
                               },
                               {
                                   0.53582679497899677, // re
                                   -0.844327925502015   // im
                               },
                               {
                                   -0.24868988716485485, // re
                                   0.96858316112863108   // im
                               },
                               {
                                   0.062790519529312833, // re
                                   -0.99802672842827156  // im
                               },
                               {
                                   6.123233995736766E-17, // re
                                   1.0                    // im
                               },
                               {
                                   0.062790519529312833, // re
                                   -0.99802672842827156  // im
                               },
                               {
                                   -0.24868988716485485, // re
                                   0.96858316112863108   // im
                               },
                               {
                                   0.53582679497899677, // re
                                   -0.844327925502015   // im
                               },
                               {
                                   -0.84432792550201485, // re
                                   0.535826794978997     // im
                               },
                               {
                                   1.0, // re
                                   0.0  // im
                               },
                               {
                                   -0.77051324277578925, // re
                                   -0.63742398974868963  // im
                               },
                               {
                                   0.062790519529313527, // re
                                   0.99802672842827156   // im
                               },
                               {
                                   0.77051324277578936, // re
                                   -0.63742398974868963 // im
                               },
                               {
                                   -0.92977648588825146, // re
                                   -0.36812455268467792  // im
                               },
                               {
                                   6.123233995736766E-17, // re
                                   1.0                    // im
                               },
                               {
                                   0.968583161128631,   // re
                                   -0.24868988716485535 // im
                               },
                               {
                                   -0.36812455268467781, // re
                                   -0.92977648588825146  // im
                               },
                               {
                                   -0.92977648588825135, // re
                                   0.36812455268467814   // im
                               },
                               {
                                   0.24868988716485474, // re
                                   0.96858316112863108  // im
                               },
                               {
                                   1.0, // re
                                   0.0  // im
                               },
                               {
                                   0.36812455268467742, // re
                                   -0.92977648588825157 // im
                               },
                               {
                                   -0.63742398974868952, // re
                                   -0.77051324277578936  // im
                               },
                               {
                                   -0.99802672842827156, // re
                                   0.062790519529313582  // im
                               },
                               {
                                   -0.63742398974868975, // re
                                   0.77051324277578925   // im
                               },
                               {
                                   6.123233995736766E-17, // re
                                   1.0                    // im
                               },
                               {
                                   0.53582679497899655, // re
                                   0.84432792550201508  // im
                               },
                               {
                                   0.84432792550201508, // re
                                   0.53582679497899666  // im
                               },
                               {
                                   0.96858316112863108, // re
                                   0.24868988716485479  // im
                               },
                               {
                                   0.99802672842827156, // re
                                   0.062790519529313374 // im
                               },
                               {
                                   1.0, // re
                                   0.0  // im
                               },
                               {
                                   0.99802672842827156, // re
                                   0.062790519529313374 // im
                               },
                               {
                                   0.96858316112863108, // re
                                   0.24868988716485479  // im
                               },
                               {
                                   0.84432792550201508, // re
                                   0.53582679497899666  // im
                               },
                               {
                                   0.53582679497899655, // re
                                   0.84432792550201508  // im
                               },
                               {
                                   6.123233995736766E-17, // re
                                   1.0                    // im
                               },
                               {
                                   -0.63742398974868975, // re
                                   0.77051324277578925   // im
                               },
                               {
                                   -0.99802672842827156, // re
                                   0.062790519529313582  // im
                               },
                               {
                                   -0.63742398974868952, // re
                                   -0.77051324277578936  // im
                               },
                               {
                                   0.36812455268467742, // re
                                   -0.92977648588825157 // im
                               },
                               {
                                   1.0, // re
                                   0.0  // im
                               },
                               {
                                   0.24868988716485474, // re
                                   0.96858316112863108  // im
                               },
                               {
                                   -0.92977648588825135, // re
                                   0.36812455268467814   // im
                               },
                               {
                                   -0.36812455268467781, // re
                                   -0.92977648588825146  // im
                               },
                               {
                                   0.968583161128631,   // re
                                   -0.24868988716485535 // im
                               },
                               {
                                   6.123233995736766E-17, // re
                                   1.0                    // im
                               },
                               {
                                   -0.92977648588825146, // re
                                   -0.36812455268467792  // im
                               },
                               {
                                   0.77051324277578936, // re
                                   -0.63742398974868963 // im
                               },
                               {
                                   0.062790519529313527, // re
                                   0.99802672842827156   // im
                               },
                               {
                                   -0.77051324277578925, // re
                                   -0.63742398974868963  // im
                               },
                               {
                                   1.0, // re
                                   0.0  // im
                               },
                               {
                                   -0.84432792550201485, // re
                                   0.535826794978997     // im
                               },
                               {
                                   0.53582679497899677, // re
                                   -0.844327925502015   // im
                               },
                               {
                                   -0.24868988716485485, // re
                                   0.96858316112863108   // im
                               },
                               {
                                   0.062790519529312833, // re
                                   -0.99802672842827156  // im
                               },
                               {
                                   6.123233995736766E-17, // re
                                   1.0                    // im
                               },
                               {
                                   0.062790519529312833, // re
                                   -0.99802672842827156  // im
                               },
                               {
                                   -0.24868988716485485, // re
                                   0.96858316112863108   // im
                               },
                               {
                                   0.53582679497899677, // re
                                   -0.844327925502015   // im
                               },
                               {
                                   -0.84432792550201485, // re
                                   0.535826794978997     // im
                               },
                               {
                                   1.0, // re
                                   0.0  // im
                               },
                               {
                                   -0.77051324277578925, // re
                                   -0.63742398974868963  // im
                               },
                               {
                                   0.062790519529313527, // re
                                   0.99802672842827156   // im
                               },
                               {
                                   0.77051324277578936, // re
                                   -0.63742398974868963 // im
                               },
                               {
                                   -0.92977648588825146, // re
                                   -0.36812455268467792  // im
                               },
                               {
                                   6.123233995736766E-17, // re
                                   1.0                    // im
                               },
                               {
                                   0.968583161128631,   // re
                                   -0.24868988716485535 // im
                               },
                               {
                                   -0.36812455268467781, // re
                                   -0.92977648588825146  // im
                               },
                               {
                                   -0.92977648588825135, // re
                                   0.36812455268467814   // im
                               },
                               {
                                   0.24868988716485474, // re
                                   0.96858316112863108  // im
                               },
                               {
                                   1.0, // re
                                   0.0  // im
                               },
                               {
                                   0.36812455268467742, // re
                                   -0.92977648588825157 // im
                               },
                               {
                                   -0.63742398974868952, // re
                                   -0.77051324277578936  // im
                               },
                               {
                                   -0.99802672842827156, // re
                                   0.062790519529313582  // im
                               },
                               {
                                   -0.63742398974868975, // re
                                   0.77051324277578925   // im
                               },
                               {
                                   6.123233995736766E-17, // re
                                   1.0                    // im
                               },
                               {
                                   0.53582679497899655, // re
                                   0.84432792550201508  // im
                               },
                               {
                                   0.84432792550201508, // re
                                   0.53582679497899666  // im
                               },
                               {
                                   0.96858316112863108, // re
                                   0.24868988716485479  // im
                               },
                               {
                                   0.99802672842827156, // re
                                   0.062790519529313374 // im
                               }};
  static const double sintabinv[129]{0.0,
                                     0.024541228522912288,
                                     0.049067674327418015,
                                     0.073564563599667426,
                                     0.0980171403295606,
                                     0.1224106751992162,
                                     0.14673047445536175,
                                     0.17096188876030122,
                                     0.19509032201612825,
                                     0.2191012401568698,
                                     0.24298017990326387,
                                     0.26671275747489837,
                                     0.29028467725446233,
                                     0.31368174039889152,
                                     0.33688985339222005,
                                     0.35989503653498811,
                                     0.38268343236508978,
                                     0.40524131400498986,
                                     0.42755509343028208,
                                     0.44961132965460654,
                                     0.47139673682599764,
                                     0.49289819222978404,
                                     0.51410274419322166,
                                     0.53499761988709715,
                                     0.55557023301960218,
                                     0.57580819141784534,
                                     0.59569930449243336,
                                     0.61523159058062682,
                                     0.63439328416364549,
                                     0.65317284295377676,
                                     0.67155895484701833,
                                     0.68954054473706683,
                                     0.70710678118654757,
                                     0.724247082951467,
                                     0.74095112535495922,
                                     0.75720884650648457,
                                     0.773010453362737,
                                     0.78834642762660634,
                                     0.80320753148064494,
                                     0.81758481315158371,
                                     0.83146961230254524,
                                     0.84485356524970712,
                                     0.85772861000027212,
                                     0.87008699110871146,
                                     0.881921264348355,
                                     0.89322430119551532,
                                     0.90398929312344334,
                                     0.91420975570353069,
                                     0.92387953251128674,
                                     0.932992798834739,
                                     0.94154406518302081,
                                     0.94952818059303667,
                                     0.95694033573220882,
                                     0.96377606579543984,
                                     0.970031253194544,
                                     0.97570213003852857,
                                     0.98078528040323043,
                                     0.98527764238894122,
                                     0.989176509964781,
                                     0.99247953459871,
                                     0.99518472667219693,
                                     0.99729045667869021,
                                     0.99879545620517241,
                                     0.99969881869620425,
                                     1.0,
                                     0.99969881869620425,
                                     0.99879545620517241,
                                     0.99729045667869021,
                                     0.99518472667219693,
                                     0.99247953459871,
                                     0.989176509964781,
                                     0.98527764238894122,
                                     0.98078528040323043,
                                     0.97570213003852857,
                                     0.970031253194544,
                                     0.96377606579543984,
                                     0.95694033573220882,
                                     0.94952818059303667,
                                     0.94154406518302081,
                                     0.932992798834739,
                                     0.92387953251128674,
                                     0.91420975570353069,
                                     0.90398929312344334,
                                     0.89322430119551532,
                                     0.881921264348355,
                                     0.87008699110871146,
                                     0.85772861000027212,
                                     0.84485356524970712,
                                     0.83146961230254524,
                                     0.81758481315158371,
                                     0.80320753148064494,
                                     0.78834642762660634,
                                     0.773010453362737,
                                     0.75720884650648457,
                                     0.74095112535495922,
                                     0.724247082951467,
                                     0.70710678118654757,
                                     0.68954054473706683,
                                     0.67155895484701833,
                                     0.65317284295377676,
                                     0.63439328416364549,
                                     0.61523159058062682,
                                     0.59569930449243336,
                                     0.57580819141784534,
                                     0.55557023301960218,
                                     0.53499761988709715,
                                     0.51410274419322166,
                                     0.49289819222978404,
                                     0.47139673682599764,
                                     0.44961132965460654,
                                     0.42755509343028208,
                                     0.40524131400498986,
                                     0.38268343236508978,
                                     0.35989503653498811,
                                     0.33688985339222005,
                                     0.31368174039889152,
                                     0.29028467725446233,
                                     0.26671275747489837,
                                     0.24298017990326387,
                                     0.2191012401568698,
                                     0.19509032201612825,
                                     0.17096188876030122,
                                     0.14673047445536175,
                                     0.1224106751992162,
                                     0.0980171403295606,
                                     0.073564563599667426,
                                     0.049067674327418015,
                                     0.024541228522912288,
                                     0.0};
  coder::array<double, 2U> b_smoothed_ppg_signal;
  coder::array<double, 2U> c_combined_coef_data;
  coder::array<double, 2U> d_combined_coef_data;
  coder::array<double, 2U> indices;
  coder::array<double, 2U> pulse;
  coder::array<double, 2U> smoothed_ppg_signal;
  double b_combined_coef_data[100];
  int combined_coef_size[2];
  int i;
  int loop_ub;
  int loop_ub_tmp;
  // SCORE_PPG_SIGNAL Returns the health scores of all pulses in a preprocessed
  //  PPG signal (via preprocess_ppg_signal(raw, timestamps)). See
  //  https://drive.google.com/file/u/3/d/1pe0JXUnOhZpmCMGCEVop8Zxzz9kD3FCD/view
  //  for complete details on algorithm, developed by Shreya.
  //  Preprocess signal and split it into pulses
  // SPLIT_PPG_SIGNAL Returns an array of indices such that each pair of
  // adjacent indices forms a pulse in the ppg signal. Also returns smoothed
  // PPG signal, but this is only for debugging
  //  Smooth the ppg signal aggressively using a moving average
  coder::filter(processed_ppg_signal, smoothed_ppg_signal);
  //  Fix the delay caused by the filter before finding the peaks
  if (smoothed_ppg_signal.size(1) - 19 < 19) {
    i = 0;
    loop_ub_tmp = 0;
  } else {
    i = 18;
    loop_ub_tmp = smoothed_ppg_signal.size(1) - 19;
  }
  loop_ub = loop_ub_tmp - i;
  b_smoothed_ppg_signal.set_size(1, loop_ub);
  for (loop_ub_tmp = 0; loop_ub_tmp < loop_ub; loop_ub_tmp++) {
    b_smoothed_ppg_signal[loop_ub_tmp] = -smoothed_ppg_signal[i + loop_ub_tmp];
  }
  coder::findpeaks(b_smoothed_ppg_signal, pulse, indices);
  //  Calculate scores of all pulses
  scores.set_size(indices.size(1) - 1);
  loop_ub = indices.size(1);
  for (int b_i{0}; b_i <= loop_ub - 2; b_i++) {
    creal_T yCol[100];
    double combined_coef_data[100];
    double d;
    double y;
    int b_loop_ub;
    scores[b_i] = 0.0;
    d = indices[b_i];
    y = indices[b_i + 1];
    if (d > y) {
      i = 0;
      loop_ub_tmp = 0;
    } else {
      i = static_cast<int>(d) - 1;
      loop_ub_tmp = static_cast<int>(y);
    }
    // PREPROCESS_PPG_PULSE Returns a processed copy of a PPG pulse
    //  Normalize and rescale to [0, 1] range
    b_loop_ub = loop_ub_tmp - i;
    smoothed_ppg_signal.set_size(1, b_loop_ub);
    for (loop_ub_tmp = 0; loop_ub_tmp < b_loop_ub; loop_ub_tmp++) {
      smoothed_ppg_signal[loop_ub_tmp] = processed_ppg_signal[i + loop_ub_tmp];
    }
    y = coder::combineVectorElements(smoothed_ppg_signal) /
        static_cast<double>(b_loop_ub);
    pulse.set_size(1, b_loop_ub);
    for (loop_ub_tmp = 0; loop_ub_tmp < b_loop_ub; loop_ub_tmp++) {
      pulse[loop_ub_tmp] = processed_ppg_signal[i + loop_ub_tmp] - y;
    }
    coder::b_abs(pulse, smoothed_ppg_signal);
    y = coder::internal::maximum(smoothed_ppg_signal);
    pulse.set_size(1, pulse.size(1));
    loop_ub_tmp = pulse.size(1) - 1;
    for (i = 0; i <= loop_ub_tmp; i++) {
      pulse[i] = pulse[i] / y;
    }
    //  Interpolate using cubic interpolation
    //  We want a fixed amount of samples for all pulses
    if (pulse.size(1) < 1) {
      smoothed_ppg_signal.set_size(1, 0);
    } else {
      smoothed_ppg_signal.set_size(1, b_loop_ub);
      for (i = 0; i <= loop_ub_tmp; i++) {
        smoothed_ppg_signal[i] = static_cast<double>(i) + 1.0;
      }
    }
    // CALCULATE_FOURIER_COEFFICIENTS Returns the real fourier coefficients of a
    // preproccessed PPG pulse
    //  FFT returns the coefficients in complex form, but we can convert that
    //  into the real form (sin/cos) using Euler's identity
    //  https://en.wikipedia.org/wiki/Sine_and_cosine_transforms#Relation_with_complex_exponentials
    coder::linspace(static_cast<double>(pulse.size(1)), combined_coef_data);
    coder::interp1(smoothed_ppg_signal, pulse, combined_coef_data,
                   b_combined_coef_data);
    coder::internal::fft::FFTImplementationCallback::doHalfLengthBluestein(
        b_combined_coef_data, yCol, wwc, dv, sintabinv);
    if (sMultiWord2Double((const unsigned int *)&coefficient_count.chunks[0U]) <
        1.0) {
      loop_ub_tmp = 0;
    } else {
      loop_ub_tmp = static_cast<int>(sMultiWord2Double(
          (const unsigned int *)&coefficient_count.chunks[0U]));
    }
    for (i = 0; i < loop_ub_tmp; i++) {
      b_combined_coef_data[i] = yCol[i].re;
    }
    d = sMultiWord2Double((const unsigned int *)&coefficient_count.chunks[0U]);
    if (d < 1.0) {
      smoothed_ppg_signal.set_size(1, 0);
    } else {
      b_loop_ub = static_cast<int>(d - 1.0);
      smoothed_ppg_signal.set_size(1, static_cast<int>(d - 1.0) + 1);
      for (i = 0; i <= b_loop_ub; i++) {
        smoothed_ppg_signal[i] = static_cast<double>(i) + 1.0;
      }
    }
    c_combined_coef_data.set(&b_combined_coef_data[0], 1, loop_ub_tmp);
    y = coder::combineVectorElements(c_combined_coef_data);
    combined_coef_size[0] = 1;
    combined_coef_size[1] = loop_ub_tmp;
    for (i = 0; i < loop_ub_tmp; i++) {
      combined_coef_data[i] = b_combined_coef_data[i] / y;
    }
    scores[b_i] =
        coder::dot(combined_coef_data, combined_coef_size, smoothed_ppg_signal);
    if (sMultiWord2Double((const unsigned int *)&coefficient_count.chunks[0U]) <
        1.0) {
      loop_ub_tmp = 0;
    } else {
      loop_ub_tmp = static_cast<int>(sMultiWord2Double(
          (const unsigned int *)&coefficient_count.chunks[0U]));
    }
    for (i = 0; i < loop_ub_tmp; i++) {
      b_combined_coef_data[i] = -yCol[i].im;
    }
    if (d < 1.0) {
      smoothed_ppg_signal.set_size(1, 0);
    } else {
      smoothed_ppg_signal.set_size(
          1, static_cast<int>(
                 sMultiWord2Double(
                     (const unsigned int *)&coefficient_count.chunks[0U]) -
                 1.0) +
                 1);
      b_loop_ub = static_cast<int>(
          sMultiWord2Double(
              (const unsigned int *)&coefficient_count.chunks[0U]) -
          1.0);
      for (i = 0; i <= b_loop_ub; i++) {
        smoothed_ppg_signal[i] = static_cast<double>(i) + 1.0;
      }
    }
    d_combined_coef_data.set(&b_combined_coef_data[0], 1, loop_ub_tmp);
    y = coder::combineVectorElements(d_combined_coef_data);
    combined_coef_size[0] = 1;
    combined_coef_size[1] = loop_ub_tmp;
    for (i = 0; i < loop_ub_tmp; i++) {
      combined_coef_data[i] = b_combined_coef_data[i] / y;
    }
    scores[b_i] =
        scores[b_i] +
        coder::dot(combined_coef_data, combined_coef_size, smoothed_ppg_signal);
  }
}

// End of code generation (preprocess_ppg_signal.cpp)
